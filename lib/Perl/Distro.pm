package Perl::Distro;

use strict;
use warnings;

use FindBin;
use Moose;

use experimental 'signatures';
use experimental 'state';

use version               ();
use Git::Wrapper          ();
use File::Slurper         ();
use File::BOM             ();
use Cwd::Guard            ();
use Cpanel::JSON::XS      ();
use CPAN::Meta::YAML      ();
use File::Basename        ();
use Pod::Markdown::Github ();
use Module::CoreList      ();
use File::Find            ();

use List::Util qw(uniq);
use File::Path qw/mkpath/;

use PPI::Document ();
use PPI::Dumper   ();

use Carp;
use Data::Dumper;
$Data::Dumper::Sortkeys = 1;

has 'distro'            => ( isa => 'Str',  is => 'ro', required => 1 );
has 'repo_path'         => ( isa => 'Str',  is => 'ro', required => 1 );
has 'git_binary'        => ( isa => 'Str',  is => 'ro', required => 1 );
has 'push_to_github'    => ( isa => 'Bool', is => 'ro', required => 1 );
has 'clean_dirty_repos' => ( isa => 'Bool', is => 'ro', default  => 1 );

has 'git'       => ( isa => 'Object',  lazy => 1,    is   => 'ro', lazy    => 1, builder => '_build_git' );
has 'dist_meta' => ( isa => 'HashRef', is   => 'rw', lazy => 1,    builder => '_build_meta' );

has 'share_files' => ( isa => 'ArrayRef', is => 'rw', default => sub { return [] } );
has 'repo_files'  => (
    isa     => 'HashRef',
    is      => 'rw',
    lazy    => 1,
    default => sub {
        return { map { ( $_ => 1 ) } shift->git->ls_files };
    }
);

has 'code_is_parseable' => ( isa => 'Bool', is => 'rw', default => 1 );

has 'builder_builder' => ( isa => 'Str', is => 'rw', builder => '_build_builder_builder' );
has 'cant_next'       => ( isa => 'Str', is => 'rw', default => '' );

has 'scripts'            => ( isa => 'ArrayRef', is => 'rw', default => sub { return [] } );
has 'requires_build'     => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'requires_runtime'   => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'requires_develop'   => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'recommends_build'   => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'recommends_runtime' => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'conflicts_runtime'  => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'provides'           => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'test_provides'      => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );

has 'ppi_cache' => ( isa => 'HashRef', is => 'rw', default => sub { return {} } );

has 'BUILD_json' => ( isa => 'HashRef', is => 'rw', default => sub { return {} } );
has 'BUILD_file' => ( isa => 'Str',     is => 'rw', default => 'BUILD.json' );

sub _build_builder_builder ($self) {
    return 'minilla' if -f 'minil.toml' && !-z _;
    return 'dzil'    if -f 'dist.ini'   && !-z _;
    if ( -f 'Build.PL' ) {
        my $c = $self->try_to_read_file('Build.PL');
        if ( $c =~ m/THIS FILE IS AUTOMATICALLY GENERATED BY MINILLA/msi ) {
            return 'minilla';
        }
        if ( $c =~ m/use Module::Build::Tiny[; ]/ms ) {
            return 'Module::Build::Tiny';
        }

        if ( $c =~ m/Module::Build::SysPath/msi ) {
            return 'Module::Build::SysPath';
        }
    }

    return '';
}

sub _build_git ($self) {
    return Git::Wrapper->new( { 'dir' => $self->repo_path, 'git_binary' => $self->git_binary } ) || die( 'Failed to create Git::Wrapper for ' . $self->repo_path );
}

sub _build_meta ($self) {

    if ( -f 'META.json' ) {
        return Cpanel::JSON::XS::decode_json( File::Slurper::read_binary('META.json') );
    }
    if ( -f 'META.yml' ) {
        my $txt  = $self->try_to_read_file('META.yml');
        my $yaml = CPAN::Meta::YAML->read_string($txt);
        return $yaml->[0] if $yaml && ref $yaml eq 'CPAN::Meta::YAML';
    }
    if ( -f 'Makefile.PL' ) {    # Generate MYMETA.json?
        `cat /dev/null | $^X Makefile.PL`;
        if ( -e 'MYMETA.json' ) {
            my $json = Cpanel::JSON::XS::decode_json( File::Slurper::read_binary('MYMETA.json') );
            $self->git->clean('-dxf');
            return $json;
        }
    }

    return { name => $self->distro, version => $self->get_version_from_log() };

    #die( 'No META data found in ' . $self->distro . "\n" . `ls -l` . "\n\n" . Carp::longmess );
}

sub get_version_from_log ($self) {
    my ($log) = $self->git->log(qw/-1 PAUSE/);
    $log or die;
    $log->{'message'} or die;
    my ($version) = $log->{'message'} =~ m{ version (\S+)};

    return $version;
}

sub dump_self ($self) {
    $self->ppi_cache( {} );
    print Dumper $self;

    return '';
}

sub is_next ($self) {
    return $self->BUILD_json->{'builder'} eq 'next';
}

sub unexpected_alien_next_check ($self) {

    # It isn't next so nothing to be worried about.
    return unless $self->is_next;

    my $distro = $self->distro;

    # It's not an alient module so we're not worried.
    return unless $distro =~ m/^Alien-/;
    return if $distro =~ m/Alien-Web-/;    # Static.

    # These modules have been vetted to be safe with next. They're just installing share or something.
    return if grep { $_ eq $distro } qw{
      Alien-BWIPP
      Alien-Build-Plugin-Build-Premake5
      Alien-Microsoft-Outlook
      Alien-Packages
      Alien-Saxon
      Alien-SeleniumRC
      Alien-SwaggerUI
      Alien-VideoLAN-LibVLC
      Alien-Web
      Alien-Win32-LZMA
      Alien-libgeos
    };

    $self->dump_self;
    die("Somehow we didn't detect that   $distro   couldn't next.");
}

sub do_the_do ($self) {
    $self->check_if_dirty_and_die;
    $self->checkout_p5_branch;

    my @log = $self->git->log(qw/p5..PAUSE/);

    # Has the PAUSE branch been updated since p5 was last merged from it?
    if (@log) {    # Reset the branch to its state on the current PAUSE branch and re-process it.
        my $git = $self->git;
        eval { $git->merge('PAUSE') };    # This will probably fail but that's ok.
        $self->delete_all_repo_files;
        my $bin = $self->git_binary;
        `$bin archive PAUSE | /usr/bin/tar -x`;
        $self->git->add( '-f', '.' );
    }
    elsif ( -e $self->BUILD_file ) {
        print "Nothing to update\n";

        # There are no new changes and BUILD.yaml has already been created.
        return;
    }

    $self->cleanup_repo_cruft;    # Cleanup files from the tarball which have nothing to do with the install.

    $self->determine_installer;            # Determine what our builder will be: next, Build.PL, or Makefile.PL
    $self->unexpected_alien_next_check;    # Most alien modules aren't next compatible.

    $self->parse_specail_files_for_license;    # Try to read special files to guess their license. TODO: move all the license stuff here.

    $self->set_primary_module_from_meta;       # Using the distro name, try to guess the primary module.

    if ( $self->is_next ) {
        $self->parse_maker_for_scripts;
        $self->parse_builders_for_share;
        $self->cleanup_tree;
        $self->update_p5_branch_from_PAUSE;
    }
    else {                                     # Build.PL or Makefile.PL
        $self->gather_non_next_provides_from_meta;
        $self->parse_non_next_primary_module;
        $self->generate_build_json;
    }

    $self->git_commit;
}

sub delete_all_repo_files ($self) {
    my $git = $self->git;

    my @files = eval { $git->ls_files };
    return unless @files;

    # remove any files and check if we succeed.
    eval { $git->rm( '-f', @files ) };
    eval { @files = $git->ls_files };
    return unless @files;

    # If we still have files, try to do it one at a time.
    foreach my $file (@files) {
        $git->rm( '-f', $file );
    }

    # fail if there are still files at this point.
    @files = $git->ls_files;
    @files and die( sprintf( "Unexpected files could not be deleted from %s repo: %s", $self->distro, Dumper \@files ) );

    return;
}

sub gather_non_next_provides_from_meta ($self) {
    my $meta = $self->dist_meta;
    return unless $meta->{'provides'};

    my $provides = $self->provides;

    foreach my $module ( sort { $a cmp $b } keys %{ $meta->{'provides'} } ) {
        $provides->{$module}->{'file'}    = $meta->{'provides'}->{$module}->{'file'};
        $provides->{$module}->{'version'} = $meta->{'provides'}->{$module}->{'version'} // 0;
    }
}

sub parse_non_next_primary_module ($self) {
    my $primary = $self->find_non_next_primary or return;
    $self->parse_pod($primary);

    return;
}

# This is only done in the event the module isn't next and we need to look around for it.
sub find_non_next_primary ($self) {
    my @parts    = split( "::", $self->BUILD_json->{'primary'} );
    my $lib_path = join( "/", 'lib', @parts ) . ".pm";
    return $lib_path if -f $lib_path;

    print "no $lib_path\n";

    my $no_lib = $parts[-1] . ".pm";
    return $no_lib if -f $no_lib;

    print "no $no_lib\n";

    return;
}

sub check_if_dirty_and_die ($self) {
    my $git = $self->git;
    my $st  = $git->status;
    return unless $st->is_dirty;

    my $txt = '';
    foreach my $status (qw/indexed changed unknown/) {
        my @status = $st->get($status) or next;
        my $type   = $status eq 'unknown' ? 'Untracked' :    #
          $status eq 'changed' ? 'Changes not staged' :      #
          'Changes to be committed';                         #
        $txt .= "$type: \n";
        foreach my $s (@status) {
            $txt .= sprintf( "  - %s\n", $s->from );
        }
    }

    if ( $self->clean_dirty_repos ) {
        eval { $git->merge('--abort') };                     # In case we were in the middle of a merge.
        $git->reset('.');
        $git->clean('-dxf');
        $git->checkout('.');
    }
    else {
        my $repo_path = $self->git->dir;
        die("\nThe repo $repo_path is unexpectedly dirty. Please correct this:\n$txt\n");
    }

    return;
}

sub checkout_p5_branch ($self) {
    my $git = $self->git;

    my @branches = eval { $git->branch };

    # the p5 branch is already there. Just switch to it.
    if ( grep { $_ =~ m/^\s*\*?\s+p5\z/ } @branches ) {
        eval { $git->checkout( '-f', 'p5' ) };
        return;
    }

    # All of this only needs to happen if we don't have a local p5 branch already.

    eval { $git->fetch('origin') };
    @branches = eval { $git->branch('-a') };

    # If the remote exists for some reason, let's check out the remote and track it.
    if ( grep { $_ =~ m{^\s*remotes/origin/p5\z} } @branches ) {
        eval { $git->checkout(qw{-t origin/p5}) };
        @branches = eval { $git->branch };

        # the p5 branch is now there.
        return if grep { $_ =~ m/^\s*\*\s+p5\z/ } @branches;
        die( "Could not checkout p5 branch from upstream in repo: " . $git->dir );
    }

    # We haven't generated the p5 branch yet. we need to fork it from PAUSE.

    # Make sure there's a PAUSE branch.
    if ( !grep { $_ =~ m/^\s*\*?\s+PAUSE\z/ } @branches ) {
        die( "Cannot create a p5 branch because PAUSE is missing for repo " . $git->dir );
    }

    $git->checkout(qw{-b p5});
    $git->reset(qw{--hard PAUSE});
    $git->push(qw{--set-upstream origin p5}) if $self->push_to_github;
}

sub is_unnecessary_dep ( $self, $module ) {
    my $distro = $self->distro;

    # Play does File::ShareDir::Install by itself.
    return 1 if $module eq 'File::ShareDir::Install' && $self->is_next;

    # We don't need this since we figure out deps on our own.
    return 1 if $module eq 'Module::Build::Prereqs::FromCPANfile' && $self->is_next;

    state $skips = {
        'Acme-CPANModules-CalculatingDayOfWeek'   => [qw{ Bencher::Backend }],
        'Acme-CPANModules-TextTable'              => [qw{ Bencher::Backend }],
        'Acme-MetaSyntactic-chinese_zodiac'       => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-christmas'            => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-countries'            => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-dangdut'              => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-display_resolution'   => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-frasier'              => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-id_names'             => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-nethack'              => [qw{ File::Find::Rule }],
        'Acme-MetaSyntactic-seinfeld'             => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-vim'                  => [qw{ File::Find::Rule }],
        'Acme-YAPC-Asia-2012-LTthon-Hakushu'      => [qw{ Test::Requires }],
        'Algorithm-BinPack-2D'                    => [qw{ Test::Requires }],
        'Algorithm-TravelingSalesman-BitonicTour' => [qw{ Pod::Coverage }],
        'Algorithm-VectorClocks'                  => [qw{ Test::NoWarnings }],
        'Alien-libgeos'                           => [qw{ Test::Deep }],
        'Amazon-S3-Thin'                          => [qw{ Config::Tiny }],
        'Analizo'                                 => [qw{ List::MoreUtils File::Share Git::Wrapper File::ShareDir}],
        'AnyEvent-IMAP'                           => [qw{ Test::Requires }],
        'AnyEvent-Inotify-Simple'                 => [qw{ Test::Exception }],
        'AnyEvent-MessagePack'                    => [qw{ Test::Requires }],
        'Amon2-MobileJP'                          => [qw{ Plack::Util }],
        'Amon2-Plugin-ShareDir'                   => [qw{ Test::Requires }],
        'AnyEvent-RabbitMQ'                       => [qw{ Test::Exception }],
        'AnyEvent-Stomper'                        => [qw{ Test::MockObject }],
        'Apache-LogFormat-Compiler'               => [qw{ Test::Requires }],
        'Apache2-AuthCASSimple'                   => [qw{ Pod::Coverage }],
        'Apache2-Controller'                      => [qw{ Math::BigInt::GMP }],
        'Apache2-WebApp-Plugin-Cookie'            => [qw{ Apache2::WebApp::Plugin::CGI }],

    };

    return unless $skips->{$distro};
    return 1 if grep { $_ eq $module } @{ $skips->{$distro} };
    return 0;
}

sub is_necessary_dep ( $self, $module ) {
    my $distro = $self->distro;

    # This is Mark's way of forcing a perl version dep. It's probably a bad idea to take it away.
    return 1 if $module eq 'Canary::Stability';

    state $keeps = {
        'AI-PredictionClient'            => [qw{ Inline::CPP Inline::MakeMaker }],    # hard to parse Inline use statement to detect Inline::CPP.
        'Acme-MathProfessor-RandomPrime' => [qw{Test::NoWarnings}],
        'Amazon-MWS'                     => [qw{ DBD::SQLite }],
        'Analizo'                        => [qw{ Alien::Doxyparse }],
        'AnyEvent-Callback'              => [qw{ AnyEvent }],
        'AnyEvent-Inotify-Simple'        => [qw{ EV }],
        'AnyEvent-Redis-RipeRedis'       => [qw{ Test::TCP }],
        'AnyEvent-RipeRedis'             => [qw{ Test::TCP }],
        'Amon2-Lite'                     => [qw{ Test::WWW::Mechanize Tiffany }],
        'Apache2-Controller'             => [qw{ LWP }],

    };

    return 1 if $distro =~ m/^Apache2-/ && ( $module eq 'Apache::TestMM' or $module eq 'Apache::Test' );
    return unless $keeps->{$distro};
    return 1 if grep { $_ eq $module } @{ $keeps->{$distro} };
    return 0;
}

# Cleanup repos that have non-standard behaviors.
# * Unexpected tarball layout ( mv PGPSign/* . )
# * .pm files are in truly unpredictable locations.
# * Fix windows cases sensitivity ( Makefile.PL NOT makefile.pl )
# * Fix the fact authors are undetectable in some cases.
# * Hard code the license for some older distros which badly specified.
# * Remove files confirmed to not be relevant to the install.
# * Remove *.swp files

sub cleanup_repo_cruft ( $self ) {

    my $distro = $self->distro;

    $self->code_is_parseable(0) if grep { $distro eq $_ } qw/Acme-Resume Amazon-SES/;

    $self->git->mv( glob('PGPSign/*'), '.' ) if ( $distro eq 'Acme-PGPSign' );
    $self->git->mv( glob('RTB/*'),     '.' ) if ( $distro eq 'Acme-RTB' );
    $self->git->mv( glob('Stegano/*'), '.' ) if ( $distro eq 'Acme-Stegano' );
    $self->git->rm( '-rf', 'local' ) if ( $distro eq 'Acme-Sort-Sleep' );
    $self->git->mv( glob('Line/Bresenham/C/*'), '.' ) if ( $distro eq 'Algorithm-Line-Bresenham-C' );

    if ( $distro eq 'Apache-OutputChain' ) {
        mkdir 'lib';
        mkdir 'lib/Apache';
        $self->git->mv( glob('[OMPS]*.pm'), 'lib/Apache' );
    }

    state $incorrect_case_files = {
        qw{
          makefile.pl Makefile.PL
          meta.json META.json
          meta.yml META.yml
          manifest MANIFEST
          readme README
          }
    };

    # Correct case insensitive files to the right case.
    foreach my $bad_file ( keys %$incorrect_case_files ) {
        next if !-e $bad_file;
        next if -e $incorrect_case_files->{$bad_file};
        $self->git->mv( $bad_file, $incorrect_case_files->{$bad_file} );
    }

    # Distro doesn't match the file.
    $self->parse_pod('Ace.pm') if $distro eq 'AcePerl';

    $self->BUILD_json->{'maintainers'} = 'Cal Henderson, <cal@iamcal.com>'          if $distro =~ /^(Acme-Goatse|Acme-OneBit)$/;
    $self->BUILD_json->{'maintainers'} = 'Audrey Tang <cpan@audreyt.org>.'          if $distro eq 'Acme-Hello';
    $self->BUILD_json->{'maintainers'} = 'Paul Fenwick.'                            if $distro eq 'Acme-OSDc';
    $self->BUILD_json->{'maintainers'} = 'David Nicol.'                             if $distro eq 'Acme-landmine';
    $self->BUILD_json->{'maintainers'} = 'Salvador Fandino <sfandino@yahoo.com>'    if $distro eq 'Algorithm-ClusterPoints';
    $self->BUILD_json->{'maintainers'} = 'Say Media'                                if $distro eq 'AnyEvent-Blackboard';
    $self->BUILD_json->{'maintainers'} = 'Yuval Kogman'                             if $distro eq 'AnyEvent-Kanye';
    $self->BUILD_json->{'maintainers'} = 'Michael A. Nachbaur'                      if $distro eq 'Apache-AxKit-Language-SpellCheck';
    $self->BUILD_json->{'maintainers'} = 'Nigel Wetters Gourlay'                    if $distro eq 'Apache-Emulator';
    $self->BUILD_json->{'maintainers'} = 'Edmund Mergl'                             if $distro eq 'Apache-LoggedAuthDBI';
    $self->BUILD_json->{'maintainers'} = 'Carlos Vicente <cvicente@ns.uoregon.edu>' if $distro eq 'Apache2-AuthenRadius';

    $self->BUILD_json->{'license'} = 'unknown' if grep { $distro eq $_ } qw{ Acme-Code-FreedomFighter ACME-Error-Translate Acme-ESP Acme-Goatse AFS AFS-Command AI-Fuzzy AI-General AIS-client AIX-LPP-lpp_name
      Acme-Lingua-Strine-Perl Acme-ManekiNeko Acme-Method-CaseInsensitive Acme-Remote-Strangulation-Protocol Acme-Turing Acme-URM Acme-Ukrop Acme-Void Algorithm-FEC Alien-KentSrc Alien-MeCab Alien-HDF4 Alien-Iconv
      Alien-Saxon AnyEvent-Kanye AnyEvent-XSPromises Apache-AuthCookieURL Apache-AuthenMT Apache-File-Resumable Apache-FileManager Apache2-FileManager Apache2-LogNotify
    };
    $self->BUILD_json->{'license'} = 'perl' if grep { $distro eq $_ } qw{ ACME-Error-31337 ACME-Error-IgpayAtinlay Acme-OSDc Acme-PM-Berlin-Meetings Acme-please Algorithm-Cluster};
    $self->BUILD_json->{'license'} = 'GPL'  if grep { $distro eq $_ } qw{ AI-LibNeural };

    state $files_to_delete = {
        'Acme-BeCool'                                => [qw{example.pm}],
        'Acme-Beatnik'                               => [qw{findwords.pl generate.pl}],
        'Acme-Blarghy-McBlarghBlargh'                => [qw{blarghymcblarghblargh.pl}],
        'Acme-Buckaroo'                              => [qw{retest.txt}],
        'Acme-Buffy'                                 => [qw{buffy}],
        'Acme-CPAN-Testers-UNKNOWN'                  => [qw{messup.PL}],
        'Acme-CPANAuthors-Acme-CPANAuthors-Authors'  => [qw{scripts/author_info.pl scripts/basic_info.pl}],
        'Test-Unit'                                  => [ 'TestRunner.pl', 'TkTestRunner.pl' ],
        'Acme-CPANAuthors-DualLife'                  => [qw{tools/duallife.pl}],
        'Acme-CPANAuthors-GitHub'                    => [qw{scripts/generate-github-authors.pl}],
        'Acme-CPANAuthors-MBTI'                      => [qw{authorlists/* misc/*}],
        'Acme-CreatingCPANModules'                   => [qw{images/* slides/*}],
        'Acme-Curses-Marquee'                        => [qw{scrolly}],
        'Acme-Dahut-Call'                            => [qw{demo/synopsis.pl}],
        'Acme-EyeDrops'                              => [qw{demo/findshapes.pl demo/gentable.pl demo/sightly.pl xBuild.PL}],
        'Acme-Flat'                                  => [qw{misc/Changes.deps misc/Changes.deps.all misc/Changes.deps.dev misc/Changes.deps.opt misc/built_with.json misc/perlcritic.deps}],
        'Acme-Futuristic-Perl'                       => [qw{COPYRIGHT}],
        'Acme-Geo-Whitwell-Name'                     => [qw{demo/zip_to_whitwell}],
        'Acme-Glue'                                  => [qw{snippets/LEEJO/hopscotch.p6 snippets/LEEJO/transform.pl snippets/SLU/MAZE.BAS snippets/SLU/schwartzian_transform.pl}],
        'AFS-Command'                                => [qw{COPYRIGHT}],
        'AI-Categorizer'                             => [qw{doc/classes-overview.png doc/classes.png}],
        'AI-Evolve-Befunge'                          => [qw{example.conf}],
        'AI-MXNetCAPI'                               => [qw{mxnet.i mxnet_typemaps.i}],
        'AI-NaiveBayes'                              => [qw{a}],
        'AI-NeuralNet-BackProp'                      => [qw{docs.htm}],
        'AI-NeuralNet-Mesh'                          => [qw{mesh.htm}],
        'AI-PSO'                                     => [qw{MPL-1.1.txt extradoc/ReactivePower-PSO-wks.pdf}],
        'AI-Pathfinding-OptimizeMultiple'            => [qw{rejects.pod}],
        'AI-Prolog'                                  => [qw{data/sleepy.pro data/spider.pro}],
        'AI-XGBoost'                                 => [qw{misc/using_capi.c}],
        'AIX-LPP-lpp_name'                           => [qw{scripts/mkcontrol}],
        'Acme-Gosub'                                 => [qw{scripts/bump-version-number.pl scripts/tag-release.pl}],
        'Acme-Hodor'                                 => [qw{unhodor.pl}],
        'Acme-JTM-Experiment'                        => [qw{AUTHOR_PLEDGE CODE_OF_CONDUCT.md}],
        'Acme-Jungle-CrawlerExample'                 => [qw{data/sample}],
        'Acme-KeyboardMarathon'                      => [qw{marathon.pl source-tree-marathon.pl}],
        'Acme-Lambda-Expr'                           => [qw{tool/operators.pl}],
        'Acme-MITHALDU-XSGrabBag'                    => [qw{README.PATCHING}],
        'Acme-Mahjong-Rule-CC'                       => [qw{mj_series}],
        'Acme-MetaSyntactic-legoindianajones'        => [qw{indie.txt}],
        'Acme-PIA-Export'                            => [qw{Acme-PIA-Export-0.019.html}],
        'Acme-Pinoko'                                => [qw{benchmark/pinoko_vs_geso.pl}],
        'Acme-PriPara'                               => [qw{etc/90_concept.t}],
        'Acme-RandomEmoji'                           => [qw{author/RandomEmoji.pm author/generate.pl author/screenshot.png}],
        'Acme-Resume'                                => [qw{iller.yaml}],
        'Acme-RunDoc'                                => [qw{foo.pl foo2.pl word-examples/helloworld.doc word-lib/Hello/World.docm}],
        'Acme-Signum'                                => [qw{signum.pl}],
        'Acme-Test-LocaleTextDomain'                 => [qw{LocaleData/id/LC_MESSAGES/Acme-Test-LocaleTextDomain.mo po/Acme-Test-LocaleTextDomain.pot po/id.po}],
        'Acme-Test-LocaleTextDomainIfEnv'            => [qw{LocaleData/id/LC_MESSAGES/Acme-Test-LocaleTextDomainIfEnv.mo po/Acme-Test-LocaleTextDomainIfEnv.pot po/id.po}],
        'Acme-Test-LocaleTextDomainUTF8IfEnv'        => [qw{LocaleData/id/LC_MESSAGES/Acme-Test-LocaleTextDomainUTF8IfEnv.mo po/Acme-Test-LocaleTextDomainUTF8IfEnv.pot po/id.po}],
        'Acme-Text-Rhombus'                          => [qw{scripts/print-rhombus.pl}],
        'Acme-Time-Asparagus'                        => [qw{VERSION}],
        'Acme-Time-Constant'                         => [qw{misc/Changes.deps misc/Changes.deps.all misc/Changes.deps.dev misc/Changes.deps.opt misc/built_with.json misc/perlcritic.deps}],
        'Acme-XSS'                                   => [qw{xss.html}],
        'Acme-rafl-Everywhere'                       => [qw{a.pl changes.patch}],
        'Activiti-Rest-Client'                       => [qw{test/*}],
        'Algorithm-BitVector'                        => [qw{Examples/BitVectorDemo.pl Examples/README Examples/testinput.txt}],
        'Algorithm-CheckDigits'                      => [qw{cgi-bin/checkdigits.cgi}],
        'Algorithm-CouponCode'                       => [qw{html/cc_icons.png html/index.html html/jquery.couponcode.css html/jquery.couponcode.js html/style.css}],
        'Algorithm-CurveFit-Simple'                  => [qw{data/hra-bhn.tsv}],
        'Algorithm-DecisionTree'                     => [qw{Examples/* ExamplesBagging/* ExamplesBoosting/* ExamplesRandomizedTrees/* ExamplesRegression/*}],
        'Algorithm-Diff'                             => [qw{cdiff.pl diff.pl diffnew.pl htmldiff.pl}],
        'Algorithm-FloodControl'                     => [qw{svn-commit.tmp}],
        'Algorithm-GenerateSequence'                 => [qw{bench_call}],
        'Algorithm-Hamming-Perl'                     => [qw{example01 example02 example03 example04}],
        'Algorithm-HowSimilar'                       => [qw{html/HowSimilar.html html/docs.css}],
        'Algorithm-LCSS'                             => [qw{html/LCSS.html html/docs.css}],
        'Algorithm-MarkovChain'                      => [qw{demos/dada demos/empty demos/textfile}],
        'Algorithm-MasterMind'                       => [qw{app/evorank.yaml app/mm-eda.cgi app/process_experiment.pl app/run_experiment.pl app/run_experiment_all.pl}],
        'Algorithm-Paxos'                            => [qw{docs/paxos-simple.pdf}],
        'Algorithm-SAT-Backtracking'                 => [qw{b/0-or.b b/1-xor.b b/2-and.b b/3-or-xor.b}],
        'Algorithm-Tree-NCA'                         => [qw{Release e/execution.log e/timing.pl}],
        'Alien-BWIPP'                                => [qw{AUTHORS}],
        'CPAN-Unwind'                                => [qw{adm/podok}],
        'Reflex'                                     => [qw{bench.pl bench/* docs/*}],
        'AMF-Perl'                                   => [qw{doc/*}],
        'AOL-TOC'                                    => [qw{tocbot/*}],
        'AOLserver-CtrlPort'                         => [qw{adm/.cvsignore adm/MANIFEST.SKIP adm/release}],
        'AlignDB-DeltaG'                             => [qw{dump/dG.yml dump/dump_dG.pl}],
        'Alt-Data-Frame-ButMore'                     => [qw{TODO.otl data-raw/* utils/*}],
        'Alvis-Pipeline'                             => [qw{bin/README etc/db/alvis.xml etc/db/xml-core.xml}],
        'Alzabo-Display-SWF'                         => [qw{etc/Tahoma-B.fdb etc/Tahoma.fdb etc/Verdana-B.fdb etc/Verdana.fdb etc/create.pl etc/my_conf.yml}],
        'Amazon-Dash-Button'                         => [qw{systemctl/Makefile systemctl/amazon-dash-button.service}],
        'Amazon-S3-FastUploader'                     => [qw{s3uploader.pl}],
        'Amethyst'                                   => [qw{factpacks/* dump.pl import.pl import.sh }],
        'Amon2-Web-Dispatcher-RouterSimple-Extended' => [qw{.dimconfig}],
        'Analizo'                                    => [qw{development-setup.sh profile.pl refresh-authors}],
        'Android-Build'                              => [qw{SampleApp/perl/generateAKey.pl SampleApp/perl/makeWithPerl.pl SampleApp/src/Activity.java}],
        'Aniki'                                      => [qw{author/*}],
        'Anki-Import'                                => [qw{out}],
        'AnnoCPAN-Perldoc-SyncDB'                    => [qw{index.html}],
        'Any-Template-ProcessDir'                    => [qw{git/config}],
        'AnyEvent-Connection'                        => [qw{.portupload.yml}],
        'AnyEvent-CouchDB'                           => [qw{edit}],
        'AnyEvent-FTP'                               => [qw{corpus/nlst/one.txt corpus/nlst/three.txt corpus/nlst/two.txt}],
        'AnyEvent-ForkManager'                       => [qw{author/requires.cpanm}],
        'AnyEvent-GnuPG'                             => [qw{COPYING}],
        'AnyEvent-ITM'                               => [qw{bundle.bat}],
        'AnyEvent-MQTT'                              => [qw{misc/*}],
        'AnyEvent-OWNet'                             => [qw{.build/* AnyEvent-OWNet-1.142000/.travis.yml}],
        'ALBD'                                       => [qw{FDL.txt config/association config/interface config/interfaceConfig config/lbd utils/datasetCreator/applyMaxThreshold.pl utils/*}],
        'Amon2'                                      => [qw{eg/* author/*}],
        'AnyEvent-RPC'                               => [qw{.portupload.yml}],
        'Acme-CPANAuthors-Japanese'                  => [qw{bin/unregistered_japanese_authors}],
        'Acme-Cow-Interpreter'                       => [qw{bin/cow.c bin/cow.pl bin/cowtidy.pl bin/text2cow.pl}],
        'Amazon-SQS-Simple'                          => [qw{bin/sqs-toolkit}],
        'AozoraBunko-Checkerkun'                     => [qw{author/bench.pl author/bench.txt author/cp932-utf8.pl author/cp932-utf8.txt author/euc2utf8.pl author/sjis2utf8.pl}],
        'Apache-ASP'                                 => [qw{build/* site/* editors/aasp.vim editors/mmm-asp-perl.el make_httpd/build_httpds.sh}],
        'Apache-Admin-Config'                        => [qw{UPGRADE-0.10}],
        'Apache-AuthCookieDBI'                       => [qw{generic_reg_auth_scheme.txt schema.sql techspec.txt}],
        'Apache-Authen-Generic'                      => [qw{README.examples}],
        'Apache-AxKit-Provider-File-Formatter'       => [qw{transforms/do-nothing.xsl transforms/xhtml2html.xsl}],
        'Apache-AxKit-Provider-OpenOffice'           => [qw{CATALOGS docs/AxKit-OOProviderUserGuide.sxw dtds/* stylesheets/oo2html.xsl stylesheets/oocommon.xsl stylesheets/ooscreen.css}],
        'Apache-Blog'                                => [qw{templates/lightblue/entry-template.html templates/lightblue/older.html templates/simple/entry-template.html templates/simple/older.html}],
        'Apache-CVS'                                 => [qw{apache_cvs.css httpd.conf}],
        'Apache-Centipaid'                           => [ 'RCS/Centipaid.pm,v', qw{VERSION config/htaccess config/htaccess-dist config/httpd.conf config/httpd.conf-dist contrib/CGI.pm-2.89.tar.gz contrib/DBD-mysql-2.1024.tar.gz sql/mysql.sql} ],
        'Apache-CodeRed'                             => [qw{CVS/Entries CVS/Repository CVS/Root}],
        'Apache-DBI'                                 => [qw{traces.txt}],
        'Apache-FilteringProxy'                      => [qw{Apache-FilteringProxy.spec}],
        'Apache-Gateway'                             => [qw{Definitions.txt FAQ.txt References.txt}],
        'Apache-Log-Parser'                          => [qw{Parser.pm}],
        'Apache-LoggedAuthDBI'                       => [qw{AuthDBI.pm DBI.pm MD5.pm SHA1.pm blocked.html brute_force.html pass_sharing.html}],
        'Apache-MP3'                                 => [qw{apache_mp3/* screenshots/*}],
        'Apache-MP3-Skin'                            => [qw{apache_mp3/*}],
        'Apache-MiniWiki'                            => [qw{Rcs-1.04-spaces.diff conf/httpd-perl-startup.pl wiki.cgi}],
        'Apache-Motd'                                => [qw{motd.txt}],
        'Apache-NNTPGateway'                         => [qw{NNTPGateway.html}],
        'Apache-OWA'                                 => [qw{CVS/Entries CVS/Repository CVS/Root}],
        'Apache-PrettyText'                          => [qw{fix_html.perl}],
        'Apache-AuthCookie'                          => [qw{README.apache-2.4.pod README.modperl2 scripts/docker-shell scripts/docker-smoke scripts/dzil-build scripts/perlbrew-smoke scripts/run-docker-tests}],
        'Apache-AuthTicket'                          => [qw{README.apache-2.4.pod sample/apache.conf sample/apache2.conf sample/mysql.sql sample/pgsql.sql scripts/perlbrew-smoke}],
        'Apache-iNcom'                               => [qw{Apache-Session-generate_id.patch Locale-Maketext-insu.patch NEWS iNcom.spec}],
        'Apache-iTunes'                              => [qw{html/iTunes.html}],
        'Apache2-AuthCAS'                            => [qw{schemaOracle.sql schemaPg.sql}],
        'Apache2-AuthColloquy'                       => [qw{NOTICE}],
        'Apache2-AuthCookieDBI'                      => [qw{README-docker docker/README docker/httpd-2.2/Dockerfile docker/httpd-2.4/Dockerfile generic_reg_auth_scheme.txt schema.sql techspec.txt}],
        'Apache2-Autocomplete'                       => [qw{ac.js}],
        'Apache2-BalanceLogic'                       => [qw{Config/MainConfig.yaml Config/PluginConfig/DistByCookie.yaml Config/PluginConfig/DistByTime.yaml Config/PluginConfig/DistByURL.yaml}],
        'Apache2-Controller'                         => [qw{util/apache2_http_response_reference_list.pl}],
        'Apache2-Imager-Resize'                      => [qw{Build}],
        'Apache2-Mogile-Dispatch'                    => [qw{doc/Subclassing.pod doc/examples/Cookie.pm doc/examples/HTTPConfig.pm doc/examples/Large.pm doc/examples/SSI.pm}],
        'Apache2-SiteControl'                        => [qw{README.UPGRADING_TO_1.0 docs/README docs/apache sample/*}],
        'Apache2-UploadProgress'                     => [qw{extra/*}],
        'Apache2_4-AuthCookieMultiDBI'               => [qw{Apache2_4-AuthCookieMultiDBI-0.03.tar}],
        'AxKit-XSP-BasicSession'                     => [qw{example.xsp}],
        'CIPP'                                       => [qw{README.Apache README.CGI README.CIPP cipp.cgi output.cgi test.cipp}],
        'Earlybird'                                  => [qw{Earlybird.README}],
        'Mandel'                                     => [qw{.ship.conf}],
        'SOAP-Lite-ActiveWorks'                      => [qw{client/* server/*}],
        'ansi-unicode'                               => [qw{sample/ED-CMSG.ICE sample/ED-CMSG.ICE.html sample/mkhtml.sh}],
        'App-perlbrew'                               => [qw{.circleci/config.yml doc/MIT-LICENSE doc/PERL-LICENSE}],

    };

    if ( $files_to_delete->{$distro} ) {
        $self->git->rm( '-f', @{ $files_to_delete->{$distro} } );
    }

    # Remove vim .swp files.
    my @files = $self->git->ls_files('*.swp');
    if (@files) {
        $self->git->rm( '-f', @files );
    }
}

sub is_extra_files_we_ship ( $self, $file, $distro = undef ) {

    # Explicit files we're going to ignore.
    return 1 if ( grep { $file eq $_ } qw/Changelog LICENSE CONTRIBUTING.md Todo author.yml FAQ/ );

    # paths with example files we're going to ignore.
    return 1 if $file =~ m{^(eg|examples?|ex)/};

    $distro //= $self->distro;

    # Wierd files for specific distros.
    return 1 if $file =~ m{^proto\b} && $distro =~ m/^AC-/;
    return 1 if $file =~ m{^fortune/}          && $distro eq 'Acme-24';
    return 1 if $file =~ m{^Roms/}             && $distro eq 'Acme-6502';
    return 1 if $file =~ m{^ascii-art\.pl$}    && $distro eq 'Acme-AsciiArtinator';
    return 1 if $file =~ m{^demo/|unbleach.pl} && $distro eq 'Acme-Bleach';
    return 1 if $file =~ m{^testlib/}          && $distro eq 'abbreviation';
    return 1 if $file eq 'acmelsd.png'    && $distro eq 'Acme-LSD';
    return 1 if $file eq 'OSDc/prog.osdc' && $distro eq 'Acme-OSDc';
    return 1 if $file eq 'test.txt'       && $distro eq 'Acme-Stegano';
    return 1 if $file eq 'sqltest.lib'    && $distro eq 'AlignDB-SQL';
    return 1 if $distro eq 'Alvis-TermTagger' and grep { $_ eq $file } qw{ etc/corpus-test-lem.txt etc/corpus-test.txt etc/termlist-test.lst };
    return 1 if $file eq 'sqltest.lib' && $distro eq 'AlignDB-SQL';
    return 1 if $file =~ m{^test/} && $distro eq 'AnyEvent-GnuPG';
    return 1 if $file =~ m{^data/} && $distro eq 'AIX-LPP-lpp_name';
    return 1 if $file eq 'MockKeyFile' && $distro eq 'Apache-AuthCookieDBI';
    return 1 if $file eq 'test.sxw'    && $distro eq 'Apache-AxKit-Provider-OpenOffice';
    return 1 if $file =~ m{^ook/}      && $distro eq 'Acme-Ook';

    return 0;
}

sub _remove_files_by_pattern ( $self, $pattern ) {
    my $files = $self->repo_files;
    foreach my $file ( keys %$files ) {
        next unless $file =~ $pattern;
        delete $files->{$file};
        $self->git->rm( '-f', $file );
    }

    return;
}

sub cleanup_tree ($self) {
    my $git   = $self->git;
    my $files = $self->repo_files;

    $self->dist_meta;    # Make sure we initialize META data in memory before removing the files.
    my $distro = $self->distro;

    # Delete garbage files we don't want.
    foreach my $unwanted_file (
        qw{ MANIFEST MANIFEST.SKIP MANIFEST.bak MANIFEST.skip INSTALL INSTALL.md INSTALL.pod INSTALL.txt INSTALL.skip INSTALL.SKIP INSTALL.Debian
        SIGNATURE dist.ini Makefile.PL Build.PL weaver.ini PROFILING.md RELEASE.md
        README README.md README.pod README.txt README.markdown README.html README.old
        BUGS META.yml META.json ignore.txt .mailmap Changes.PL cpanfile cpanfile.snapshot minil.toml
        .gitignore .gitattributes  .cvsignore .travis.yml travis.yml appveyor.yml .appveyor.yml .proverc .DS_Store
        .project t/boilerplate.t MYMETA.json MYMETA.yml Makefile Makefile.old maint/Makefile.PL.include metamerge.json README.bak dist.ini.bak
        AUTHORS CREDITS doap.ttl author_test.sh cpants.pl makeall.sh perlcritic.rc .perltidyrc .perltidy dist.ini.meta Changes.new Changes.old
        CONTRIBUTORS tidyall.ini .perlcriticrc perlcriticrc perltidyrc README.mkdn .shipit example.pl pm_to_blib
        install.txt install.sh install.cmd install.bat .settings/org.eclipse.core.resources.prefs .includepath META.ttl Makefile.PL.back
        Artistic_License.txt GPL_License.txt LICENSE.txt LICENSE.GPL LICENSE.Artistic misc/make_manifest.pl GPL.txt ARTISTIC-1.0 GPL-1 ARTISTIC GPL License.Artistic License.GPL
        Dockerfile HACKING.md SUPPORT ABSTRACT
        }
    ) {
        next unless $files->{$unwanted_file};
        delete $files->{$unwanted_file};
        $git->rm( '-f', $unwanted_file );
    }

    # Throw out repo tarballs.
    $self->_remove_files_by_pattern(qr{^\Q$distro\E-.+\.tar\.gz$});

    # Throw out maint/cip- files. Not sure what they are.
    $self->_remove_files_by_pattern(qr{^maint/(cip-|release)});

    # Throw out meta/*.pret
    $self->_remove_files_by_pattern(qr{/.+\.pret$});

    # Throw out repo directories
    $self->_remove_files_by_pattern(qr{^\.(svn|hg)/|/\.(svn|hg)/});

    # Get rid of directories we don't want.
    $self->_remove_files_by_pattern(qr{^(?:inc|samples|Samples|demo|debian|tools|benchmark|devdata|devscript|devscripts|_build|maint|ubuntu-)/});

    # *~ or /#file# (emacs backups)
    $self->_remove_files_by_pattern(qr{~$|/#.+#$|^#.+#$});

    # Normalize all TODO files to 'Todo' and throw out the boilerplate ones.
    my @todo = sort grep { $_ =~ m/^todo(\.(md|txt))?$|^(readme.todo)$/i } keys %$files;
    if (@todo) {
        scalar @todo == 1 or die( "Too many TODO files.\n" . Dumper($files) );
        my $todo = shift @todo;
        if ( $todo ne 'Todo' ) {
            delete $files->{$todo};
            $files->{'Todo'} = 1;
            $git->mv( $todo, 'Todo' );
        }

        # See if the TODO is worthless.
        my $content = $self->try_to_read_file('Todo');
        if ( $content =~ m/- Nothing yet/ms ) {
            $git->rm( '-f', 'Todo' );
            delete $files->{'Todo'};
        }
    }

    # Deal with unneeded debian COPYRIGHT file.
    if ( $files->{'COPYRIGHT'} && $files->{'LICENSE'} ) {
        open( my $fh, '<', 'COPYRIGHT' ) or die("Can't read COPYRIGHT: $!");
        my $line = <$fh>;
        if ( $line =~ m/^Format: http.+debian/ ) {
            close $fh;
            $git->rm('COPYRIGHT');
            delete $files->{'COPYRIGHT'};
        }
    }

    # Alternative license files. LICENCE
    foreach my $license_variant (qw/COPYRIGHT LICENCE COPYING/) {
        next unless $files->{$license_variant};
        $files->{'LICENSE'} and die("Unexpectedly found LICENSE and $license_variant in the same distro");

        $git->mv( $license_variant, 'LICENSE' );

        $files->{'LICENSE'} = 1;
        delete $files->{$license_variant};
    }

    # Normalize all CONTRIBUTING files to a common 'CONTRIBUTING.md'
    foreach my $contrib_variant (qw{CONTRIBUTING CONTRIBUTING.mkdn docs/SubmittingPatches.pod}) {
        next unless $files->{$contrib_variant};

        $files->{'CONTRIBUTING.md'} && die("Unexpectedly saw CONTRIBUTING.md and $contrib_variant in the same repo. I don't know what to do");

        print "Renaming $contrib_variant to CONTRIBUTING.md\n";
        $git->mv( $contrib_variant, 'CONTRIBUTING.md' );
        delete $files->{$contrib_variant};
        $files->{'CONTRIBUTING.md'} = 1;
        last;    # We can't move 2 files to the same destination so this will fail later.
    }

    # Normalize all Changelog files to a common 'Changelog'
    foreach my $changes_variant (qw/CHANGES CHANGELOG Changes ChangeLog CHANGELOG.md CHANGE/) {
        next unless $files->{$changes_variant};

        $files->{'Changelog'} && die("Unexpectedly saw Changelog and $changes_variant in the same repo. I don't know what to do");

        print "Renaming $changes_variant to Changelog\n";
        $git->mv( $changes_variant, 'Changelog' );
        delete $files->{$changes_variant};
        $files->{'Changelog'} = 1;
        last;    # We can't move 2 files to the same destination so this will fail later.
    }

    # Re-locate t/ test files that belong in xt/
    foreach my $file ( sort { $a cmp $b } keys %$files ) {
        next unless $self->is_xt_test($file);

        print "Moving $file to xt/\n";

        mkdir('xt');
        $git->mv( $file, 'xt/' );

        # update the files hash.
        delete $files->{$file};
        $file =~ s{^t/}{xt/};
        $files->{$file} = 1;
    }

    # Move test.pl into t/test_pl.t
    if ( -f 'test.pl' ) {
        mkdir 't';
        -e 't/test_pl.t' and die("Unexpected test.pl / test_pl.t combo??");
        $git->mv( 'test.pl', 't/test_pl.t' );
        delete $files->{'test.pl'};
        $files->{'t/test_pl.t'} = 1;
    }

    return;
}

sub reset_repo_files ($self) {
    $self->repo_files( { map { ( $_ => 1 ) } $self->git->ls_files } );
}

sub set_primary_module_from_meta ($self) {
    my $build_json = $self->BUILD_json;
    my $distro     = $self->distro;

    # Try to determine the primary package of this distro.
    # Let's make sure it matches the 'name' of the module.
    $build_json->{'primary'} = $self->dist_meta->{'name'};
    $build_json->{'primary'} =~ s/-/::/g;
    $build_json->{'primary'} =~ s/\\?'/::/g;    # Acme::Can't

    # Non-obvious primaries.
    $build_json->{'primary'} = 'AnyEvent::RFXCOM::TX'               if $distro eq 'AnyEvent-RFXCOM';
    $build_json->{'primary'} = 'Apache2::AMFDetectRightFilter'      if $distro eq 'Apache2-ApacheMobileFilter';
    $build_json->{'primary'} = 'SOAP::Transport::ActiveWorks::Lite' if $distro eq 'SOAP-Lite-ActiveWorks';
    $build_json->{'primary'} = 'ANSI::Unicode'                      if $distro eq 'ansi-unicode';
    $build_json->{'primary'} = 'Apache2::LogUtil'                   if $distro eq 'perl-Apache2-LogUtil';

    return;
}

sub relocate_modules_to_lib ($self) {
    my $git        = $self->git;
    my $build_json = $self->BUILD_json;
    my $files      = $self->repo_files;

    $self->is_next or die;    # Shouldn't ever get here. We shouldn't alter the location of the module if we're not a next module.

    # Move the module into lib/ if we need to.
    my @module      = split( '::', $build_json->{'primary'} );
    my $module_path = join( '/', ( 'lib', @module ) ) . ".pm";

    if ( !-d 'lib' && -d $module[0] ) {
        printf( "Moving root name space (%s) into lib/\n", $module[0] );
        mkdir 'lib';
        $git->mv( $module[0], 'lib/' );

        # There's no easy way to update $self->repo_files. We're going to have to re-scan it.
        $self->reset_repo_files;
        $files = $self->repo_files;
    }

    if ( !$files->{$module_path} ) {

        my $filename = $module[-1] . ".pm";
        if ( $files->{$filename} ) {
            print "Primary module $module_path is in the wrong place. It is being moved.\n";
            mkpath($module_path);
            rmdir $module_path;
            $git->mv( $filename, $module_path );

            delete $files->{$filename};
            $files->{$module_path} = 1;
        }

        # Possibly the submodules also need to be moved.
        my $dir_path = join( '/', ( 'lib', @module ) );
        my $dir      = $module[-1];
        if ( -d $dir && !-d $dir_path ) {
            print "Detected submodules in the wrong place. Moving those too.\n";
            $git->mv( $dir, $dir_path );

            # There's no easy way to update $self->repo_files. We're going to have to re-scan it.
            $self->reset_repo_files;
            $files = $self->repo_files;
        }
    }

    if ( !-f $module_path ) {
        $self->dump_self;
        die("Can't find $module_path");
    }

    return;
}

sub cleanup_and_grep ( $self, $grep ) {
    $self->git->reset('.');
    $self->git->checkout('.');
    $self->git->clean('-dxf');
    print "Grep:\n";
    print `git grep -iP '$grep'`;
}

# We can assume we are checked out into the p5 branch but it is
# Indeterminate if PAUSE has merged in or if the p5 branch has been
# converted.
sub update_p5_branch_from_PAUSE ($self) {
    my $git        = $self->git;
    my $distro     = $self->distro;
    my $build_json = $self->BUILD_json;
    my $meta       = $self->dist_meta;

    $build_json->{'xs'} and die("next doesn't support xs distros");

    $self->relocate_modules_to_lib;

    # If test paths are specified in META, transfer that unless they're just t/* or t/*.t.
    if ( $meta->{'tests'} ) {
        my $tests = $meta->{'tests'};
        delete $meta->{'tests'};
        if ( $tests !~ m{^t/*\S+$} ) {
            $build_json->{'tests'} = [ map { $_ .= ".t" if m/\*$/; $_ } split( " ", $tests ) ];
        }
    }

    $self->gather_non_next_provides_from_meta unless $self->code_is_parseable;

    my $files = $self->repo_files;
    foreach my $file ( sort { $a cmp $b } keys %$files ) {
        $self->parse_code($file) if $self->code_is_parseable;
        $self->parse_comments($file);
        $self->parse_pod($file);
    }

    {    #  Look for any unexpected files in the file list.
        my %files_copy = %{ $self->repo_files };

        foreach my $script ( @{ $self->scripts } ) {
            $build_json->{'scripts'} ||= [];

            push @{ $build_json->{'scripts'} }, $script;
            delete $files_copy{$script};
        }

        #Anything in lib, t, xt is good. Just pass it through.
        delete $files_copy{$_} foreach grep { m{^lib/|^t/|^xt/} } keys %$files;

        # Files we know are ok, we'll delete from the hash.
        foreach my $file ( sort keys %files_copy ) {
            delete $files_copy{$file} if $self->is_extra_files_we_ship( $file, $distro );
        }

        # Detected share files.
        foreach my $file ( @{ $self->share_files } ) {
            delete $files_copy{$file};
        }

        # Nothing was found.
        #         'Acme-CPANAuthors-GitHub'                 => [qw{scripts/generate-github-authors.pl}],
        if (%files_copy) {
            my @unexpected_files = sort { $a cmp $b } keys %files_copy;
            printf( "Unexpected files found in    %s\n%s\n", $distro, Dumper( \%files_copy ) );
            my $grep = join( '|', @unexpected_files );
            $self->cleanup_and_grep($grep);
            printf( "\n        '%s'                 => [qw{%s}],\n", $distro, join( " ", @unexpected_files ) );
            die;
        }
    }

    $self->generate_build_json;

    state $readme_map = {
        'Just-Another-Perl-Hacker' => 'lib/Just/Another/Perl/Hacker.pm',
    };

    {    # Generate README.md from the primary module.

        my $primary_file = $readme_map->{$distro};
        if ( !$primary_file ) {    # Normally we'd guess it from the primary module name.
            $self->BUILD_json->{'provides'}->{ $self->BUILD_json->{'primary'} }->{'file'} or die( "Unexpected primary file location not found:\n" . Dumper $self->BUILD_json );
            $primary_file = $self->BUILD_json->{'provides'}->{ $self->BUILD_json->{'primary'} }->{'file'};
        }

        my $primary_file_stem = $primary_file;
        $primary_file_stem =~ s/\.pm$//;
        $primary_file = -e "$primary_file_stem.pod" ? "$primary_file_stem.pod" : $primary_file;

        my $markdown;
        my $parser = Pod::Markdown::Github->new;
        $parser->unaccept_targets(qw( html ));
        $parser->output_string( \$markdown );
        $parser->parse_string_document( $self->try_to_read_file($primary_file) );
        File::Slurper::write_text( 'README.md', $markdown );
        -f 'README.md' && !-z _ or die("Couldn't generate README.md");

        $git->add('README.md');
    }

    return;
}

sub try_to_read_file ( $self, $filename ) {
    -f $filename or return;
    -z _ and return '';

    local $@;
    my $contents;
    eval { $contents = File::Slurper::read_text($filename); 1 } and return $contents;
    print "Trying latin 1 on $filename\n";
    eval { $contents = File::Slurper::read_binary($filename); 1 } and return $contents;
    die("Could not parse $filename: $@");
}

sub git_commit ($self) {
    my $git = $self->git;

    $git->commit( '-m', sprintf( "Update %s version %s to next.", $self->distro, $self->BUILD_json->{'version'} ) );

    $git->push if $self->push_to_github;

    return;
}

# Is responsible for setting the following:
# * $build_json->{'builder'}
# * $build_json->{'xs'}
# * $self->cant_next('...')

sub determine_installer ( $self ) {
    my $build_json = $self->BUILD_json;
    my $files      = $self->repo_files;
    my $distro     = $self->distro;

    my $builder = 'next';

    # Tag the BUILD file with whether this repo has XS.
    if ( grep { $_ =~ m/\.xs(.inc)?$/ } keys %$files ) {
        $build_json->{'xs'} = 1;
        $builder = 'legacy';
        $self->cant_next('xs');
        print "Detected .xs files in distro\n";
    }
    else {
        $build_json->{'xs'} = 0;
    }

    if ( grep { $distro eq $_ } qw/Acme-Padre-PlayCode Alien-TALib Apache-GeoIP Win32-SerialPort/ ) {
        $builder = 'legacy';
        $self->cant_next('Manual detection');
        print "Manually determined that $distro could not be used with next\n";
    }

    # .PL files usually indicate something that needs to be generated.
    my @files;
    if ( @files = grep { $_ =~ m/\.PL$/ && $_ !~ m{^(Build|Makefile|t/TEST)\.PL$} && $_ !~ m{^share/} } keys %$files ) {
        printf( "Detected %s files which indicate a dynamic generation which can't next yet!\n", join( ", ", @files ) );
        $self->cant_next('.PL files');
        $builder = 'legacy';
    }

    # Other than .PL files and XS/C, Module::Build::Tiny is just for vanilla installs.
    if ( $builder eq 'next' && $self->builder_builder eq 'Module::Build::Tiny' ) {
        $build_json->{'builder'} = 'next';
        return;
    }

    # This isn't really a builder builder but since we had the file open we detected
    # that it doesn't really support next right now.
    if ( $self->builder_builder eq 'Module::Build::SysPath' ) {
        $self->cant_next('Module::Build::SysPath');
        $builder = 'legacy';
    }

    # These modules customize the default Maker in a way we can't simulate.
    my @banned_modules = qw/Alien::Base Inline::C Inline::CPP Alien::Build Alien::autoconf Alien::m4 Alien::automake Alien::libtool FFI::Build::MM/;
    my $meta           = $self->dist_meta;
    my @exceptions;
    if ( $meta->{'prereqs'} && ref $meta->{'prereqs'} eq 'HASH' ) {
        foreach my $prereq ( values %{ $meta->{'prereqs'} } ) {
            next unless @exceptions = grep { defined $prereq->{'requires'}->{$_} } @banned_modules;
            $builder = 'legacy';
            my $banned_modules = join( ", ", @exceptions );
            $self->cant_next("banned $banned_modules");
            print "The Build/install modules ($banned_modules) make the installer unable to next.\n";
            last;
        }
    }

    foreach my $meta_requires (qw/configure_requires build_requires requires test_requires/) {
        next unless ref $meta->{$meta_requires} eq 'HASH';
        next unless @exceptions = grep { defined $meta->{$meta_requires}->{$_} } @banned_modules;
        $builder = 'legacy';
        my $banned_modules = join( ", ", @exceptions );
        $self->cant_next("banned $banned_modules");
        print "The Build/install modules ($banned_modules) make the installer unable to next.\n";
        last;
    }

    # Validate x_static_install matches our own decision.
    if ( exists $meta->{'x_static_install'} ) {
        if ( $meta->{'x_static_install'} && $builder ne 'next' ) {
            die('x_static_install says this distro is static but I detected things that might make it legacy');
        }
        if ( !$meta->{'x_static_install'} && $builder eq 'next' ) {
            $builder eq 'legacy' or warn(q{x_static_install says his distro isn't static but I don't know why it is next at this point?});
            $builder = 'legacy';
            $self->cant_next("x_static_install=0");
            print "Detected x_static_install=0\n";
        }
        delete $meta->{'x_static_install'};
    }

    # we ignore all the wierd in minilla
    if ( $builder ne 'legacy' and -e 'Build.PL' && $self->builder_builder ne 'minilla' ) {

        my @found = eval { $self->git->grep('ACTION_install') };
        if (@found) {
            print "Build.PL distro is using ACTION_install somewhere. Cannot next.\n";
            $self->cant_next("ACTION_install");
            $builder = 'legacy';
        }

        my $content = $self->try_to_read_file('Build.PL');

        if ( $content =~ m/(My::Builder\S+)/msi ) {
            print "Custom build logic found in Build.PL: $1\n";
            $self->cant_next("My::Builder");
            $builder = 'legacy';
        }
        elsif ( $content =~ m/Module::Build->subclass/ms ) {
            print "Build.PL is subclassing so it must be doing something wierd. Skipping next.\n";
            $self->cant_next("Module::Build->subclass");
            $builder = 'legacy';
        }
        elsif ( $content =~ m/add_build_element/ms ) {
            print "Build.PL is using add_build_element. Skipping next.\n";
            $self->cant_next("add_build_element");
            $builder = 'legacy';
        }
        elsif ( $distro =~ m/^Alien-/ && $content =~ m/use lib [^;]*inc/ ) {
            print "Alien module via Build.PL is using inc/. I suspect it can't next\n";
            $self->cant_next("use of inc/ with Alien modules");
            $builder = 'legacy';
        }
        elsif ( $content =~ m/use\s+ExtUtils::Liblist/ ) {
            print "Build.PL is using ExtUtils::Liblist. Can't next!\n";
            $self->cant_next("ExtUtils::Liblist");
            $builder = 'legacy';
        }
        elsif ( $content =~ m/install_path/msi ) {
            print "Build.PL is using install_path. Can't next!\n";
            $self->cant_next("install_path");
            $builder = 'legacy';
        }

        if ( $builder ne 'legacy' and $content =~ m/sys_files/msi ) {
            print "Need to implement support for install_path, sys_files in Build.PL";
            ...;
            $builder = 'legacy';
        }
        if ( $builder ne 'legacy' ) {

            # die("Undetected legacy");
        }

        # Parse Build.PL for install_path or sys_files and ban the use of the module.
    }

    # No XS but maybe OBJECTS is mentioned in Makefile.PL?
    if ( $builder ne 'legacy' and -f 'Makefile.PL' ) {
        local $@;
        my $doc = $self->get_ppi_doc('Makefile.PL');
        die if !$doc;

        my ($object) = $self->_ppi_find_and_parse_value_for_key( $doc, 'OBJECT' );
        $object = strip_quotes($object) if length $object;
        if ( length $object ) {
            $builder = 'legacy';
            $self->cant_next("OBJECT => $object");
            printf( "Detected a legacy build due to OBJECT => %s in Makefile.PL\n", $object );
        }
        elsif ( $self->_ppi_find_class_and_content( $doc, 'PPI::Token::Word', 'postamble' ) ) {
            $builder = 'legacy';
            $self->cant_next("postamble in Makefile.PL");
            printf("Detected a postamble in Makefile.PL. Something can't be installed with next.\n");
        }
        elsif ( $self->_ppi_find_class_and_content( $doc, 'PPI::Token::Word', 'MY::postamble' ) ) {
            $builder = 'legacy';
            $self->cant_next("MY::postamble in Makefile.PL");
            printf("Detected MY::postamble in Makefile.PL. Can't next.\n");
        }
        elsif ( $self->_ppi_find_class_and_content( $doc, 'PPI::Token::Word', 'prompt_script' ) ) {
            $builder = 'legacy';
            $self->cant_next("Module::Install prompt_script");
            printf("Detected a M::I prompt_script  in Makefile.PL. Something can't be installed with next.\n");
        }
        elsif ( $self->_ppi_find_class_and_content( $doc, 'PPI::Token::Word', 'inline' ) ) {
            $builder = 'legacy';
            $self->cant_next("Module::Install use of Inline");
            printf("Detected a M::I inline in Makefile.PL. Something can't be installed with next.\n");
        }
        elsif ( $distro =~ m/^Alien-/ and $self->_ppi_find_class_and_content( $doc, 'PPI::Token::QuoteLike::Backtick', qr/`/ ) ) {
            $builder = 'legacy';
            $self->cant_next("Backticks in Makefile.PL");
            printf("Makefile.PL uses backticks.\n");
        }
        else {
            #die dump_tree($doc);
        }

        #        if($builder eq 'next') { die dump_tree($doc, "postamble stuff.") }
    }

    # Force the cache on maker files. Often we need to peek back at the makers and we remove them early.
    foreach my $builder (qw/Build.PL Makefile.PL/) {
        next unless -f $builder && !-z _;
        $self->get_ppi_doc($builder);
    }

    # If the builder is next, then set it and return.
    if ( $builder eq 'next' ) {
        $build_json->{'builder'} = 'next';
        return;
    }

    # Guess based on what builder to use based on files in the repo.
    $build_json->{'builder'} = $files->{'Build.PL'} ? 'Build.PL' : $files->{'Makefile.PL'} ? 'Makefile.PL' : die("Can't determine builder for distro $distro");
    return;
}

# $self->_ppi_find_class_and_content( $doc, 'PPI::Token::QuoteLike::Backtick', qr/`/
# $self->_ppi_find_class_and_content( $doc, 'PPI::Token::Word', 'prompt_script'

sub _ppi_find_class_and_content ( $self, $doc, $class, $content ) {

    return $doc->find(
        sub ( $self, $node ) {
            if ( ref $class ) {
                $node->class =~ $class or return 0;
            }
            else {
                $node->class eq $class or return 0;
            }

            if ( ref $content ) {
                $node->content =~ $content or return 0;
            }
            else {
                $node->content eq $content or return 0;
            }
            return 1;
        }
    );
}

sub parse_license_file ($self) {
    my $files = $self->repo_files;
    return unless $files->{'LICENSE'};
    my $content = $self->try_to_read_file('LICENSE');

    return 'perl' if $content =~ m/Terms\s*(of|as)\s*Perl\s*itself/msi;
    return 'MIT'  if $content =~ m/The MIT Licens/msi;
    return;

}

sub _is_a_hash_ref ($ref) {
    return unless $ref;
    return unless ref($ref) eq 'HASH';
    return 1;
}

sub generate_build_json ($self) {
    my $build_json = $self->BUILD_json;
    my $meta       = $self->dist_meta;
    my $distro     = $self->distro;

    $meta->{'version'} ||= $self->get_version_from_log();
    $build_json->{'version'} = $meta->{'version'};

    # Sometimes the meta license isn't just a string. Let's normalize it.
    if ( ref $meta->{'license'} eq 'ARRAY' ) {
        $meta->{'license'} = join( ", ", @{ $meta->{'license'} } );
    }
    ref $meta->{'license'} and die( "Unexpected meta license data: " . Dumper $meta);

    # unknown isn't a valid license except when it is.
    # We have a few distros which truly don't have a meaningful license.
    if ( $meta->{'license'} && $meta->{'license'} eq 'unknown' ) {
        if ( $build_json->{'primary'} !~ m{^(ACL::Regex)$} ) {
            delete $meta->{'license'};
        }
    }

    # Use the meta license preferentially if it's there.
    if ( $meta->{'license'} ) {
        $build_json->{'license'} = $meta->{'license'};
    }

    # Last attempt try reading LICENSE
    if ( !$build_json->{'license'} ) {
        $build_json->{'license'} = $self->parse_license_file;
        if ( !$build_json->{'license'} ) {
            $self->dump_self;
            printf( "Missing license for   %s\n\n", $self->distro );
            $self->cleanup_and_grep('license|copyright');
            die;
        }
    }

    # Put provides into BUILD.json
    if ( !$self->code_is_parseable ) {
        $build_json->{'unparseable'} = 1;
    }

    $build_json->{'provides'} = $self->provides;

    if ( $self->is_next ) {
        %{ $self->provides } or die("Every module should provide something. This provides nothing?");
    }

    # Decode the resource urls. These have been inconsistently stored over the years.
    foreach my $resource (qw/bugtracker repository/) {
        next unless $meta->{'resources'}->{$resource};
        my $value = $meta->{'resources'}->{$resource};

        my $value_ref = ref $value;
        $value = !$value_ref ? $value : $value_ref eq 'HASH' ? $value->{'web'} : die( "Unexpected resources structure for $resource:\n" . Dumper( $meta->{'resources'} ) );

        $build_json->{$resource} = $value;
    }

    # unused vars in meta.
    delete $meta->{$_} foreach (
        qw/dynamic_config generated_by meta-spec x_generated_by_perl x_serialization_backend license resources x_deprecated
        release_status x_Dist_Zilla x_authority distribution_type installdirs version_from x_contributors x_spdx_expression
        x_test_requires x_authority_from_module x_permissions_from_module x_BuiltWith module_name x_contributor_covenant
        x_provides_scripts x_static_install/
    );

    # Initialize the misc meta fields into hashes if they're missing.
    $meta->{$_} ||= {} foreach qw/configure_requires requires build_requires develop_requires/;

    # We need to merge the prereq map into various destinations.
    my $prereq_map = {
        build => {
            requires   => $meta->{'build_requires'},
            recommends => $self->recommends_build,
            suggests   => $self->recommends_build,
        },
        test => {
            requires   => $meta->{'build_requires'},
            recommends => $self->recommends_build,
            suggests   => $self->recommends_build,
        },
        configure => {
            requires   => $meta->{'configure_requires'},
            recommends => $self->recommends_build,
            suggests   => $self->recommends_build,
        },
        develop => {
            requires   => $meta->{'develop_requires'},
            recommends => $meta->{'develop_requires'},
            suggests   => $meta->{'develop_requires'},
        },
        runtime => {
            requires    => $meta->{'requires'},
            recommends  => $self->recommends_runtime,
            suggests    => $self->recommends_runtime,
            conflicts   => $self->conflicts_runtime,
            x_conflicts => $self->conflicts_runtime,
        },
    };

    # Walk the prereqs section of $meta using the prereq_map and re-locate the deps to a consistent location.
    my $prereq_hash = $meta->{'prereqs'} //= {};
    foreach my $prereq_key ( sort { $a cmp $b } keys %$prereq_map ) {    # build configure develop runtime test
        next unless _is_a_hash_ref( $prereq_hash->{$prereq_key} );
        foreach my $require_type ( sort { $a cmp $b } keys %{ $prereq_map->{$prereq_key} } ) {    # requires recommends suggests conflicts x_conflicts.
            next unless _is_a_hash_ref( $prereq_hash->{$prereq_key}->{$require_type} );
            merge_dep_into_hash( $prereq_hash->{$prereq_key}->{$require_type}, $prereq_map->{$prereq_key}->{$require_type} );
            delete $prereq_hash->{$prereq_key}->{$require_type};
        }

        # Look for x_* keys in this prereq which we don't know or care about.
        foreach my $garbage_key ( grep { m/^x_/ } keys %{ $prereq_hash->{$prereq_key} } ) {
            print "Deleting unsupported prereq for '$prereq_key' key '$garbage_key'\n";
            delete $prereq_hash->{$prereq_key}->{$garbage_key};
        }
        prune_ref( $prereq_hash->{$prereq_key} );
        keys %{ $prereq_hash->{$prereq_key} } and die( "Unexpected prereqs found in $prereq_key:\n" . Dumper $meta);
    }

    # Strip out any x_ prereqs. We don't care about them.
    foreach my $prereq_key ( grep { m/^x_/ } keys %{ $meta->{'prereqs'} } ) {
        print "Deleting non-standard prereq section $prereq_key\n";
        delete $meta->{'prereqs'}->{$prereq_key};
    }

    # Strip everything out of $meta and see if there are still prereqs.
    prune_ref($meta);
    $meta->{'prereqs'} and die( "Unexpected prereqs found:\n" . Dumper $meta);

    my $provides      = $self->provides;
    my $test_provides = $self->test_provides;
    foreach my $req ( $self->requires_build, $self->requires_runtime, $self->requires_develop ) {
        foreach my $module ( keys %$req ) {
            delete $req->{$module} if $provides->{$module} or $test_provides->{$module};
        }
    }

    if ( $meta->{'x_conflicts'} && ref $meta->{'x_conflicts'} eq 'HASH' ) {
        foreach my $conflict ( keys %{ $meta->{'x_conflicts'} } ) {
            $self->conflicts_runtime->{$conflict} = $meta->{'x_conflicts'}->{$conflict};
        }
        delete $meta->{'x_conflicts'};
    }

    # Merge in detected requires_runtime into BUILD.yaml. Validate against META as we go.
    foreach my $req (qw/requires recommends build_requires test_requires configure_requires develop_requires/) {
        my $build_req_name =
            $req eq 'requires'           ? 'requires_runtime'
          : $req eq 'recommends'         ? 'recommends_runtime'
          : $req eq 'build_requires'     ? 'requires_build'
          : $req eq 'configure_requires' ? 'requires_build'
          : $req eq 'test_requires'      ? 'requires_build'
          : $req eq 'develop_requires'   ? 'requires_develop'
          :                                die("Unknown req $req");

        my $build_req = $self->$build_req_name;

        foreach my $module ( keys %{ $meta->{$req} } ) {

            # Skip specifying our own modules in require sections.
            if ( $provides->{$module} ) {
                delete $meta->{$req}->{$module};
                next;
            }

            # These requirements never move over to p5.
            if ( $self->is_next && $module =~ m/^(?:ExtUtils::MakeMaker|Module::Build|App::ModuleBuildTiny|Module::Build::Tiny|(inc::)?Module::Install|Module::Build::Pluggable(?:::.+)?|ExtUtils::MakeMaker::CPANfile|Module::Install|strict|warnings|version|lib)$/ ) {
                delete $meta->{$req}->{$module};
                next;
            }

            # special handling for minimum perl version.
            if ( $module eq 'perl' ) {
                $meta->{$req}->{$module} =~ s{^\s*>=\s*}{};
                $build_req->{$module} = $meta->{$req}->{$module};
                delete $meta->{$req}->{$module};
                next;
            }

            # Let's not be so strict on develop requires. Maybe they know what they're talking about.
            # Also who cares? next doesn't use develop_requires right now.
            if ( !exists $build_req->{$module} && $req eq 'develop_requires' ) {
                $build_req->{$module} = $meta->{$req}->{$module};
                delete $meta->{$req}->{$module};
                next;
            }

            # Add a recommends section.
            if ( !exists $build_req->{$module} && $req eq 'requires' ) {
                $build_req->{$module} = $meta->{$req}->{$module};
                delete $meta->{$req}->{$module};
                next;
            }

            if ( !$self->code_is_parseable ) {
                1;    #
            }
            elsif ( !exists $build_req->{$module} ) {
                if ( !$self->is_next or $req eq 'recommends' ) {    # Just pass it through.
                    $build_req->{$module} = $meta->{$req}->{$module};
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( ( grep { $req eq $_ } qw/configure_requires test_requires build_requires/ ) && exists $self->requires_runtime->{$module} ) {    # ignore build stage requires if runtime requires it.
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( $self->is_dual_life($module) ) {
                    $build_req->{$module} = $meta->{$req}->{$module};
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( $self->is_unnecessary_dep($module) ) {
                    print "Skipping dep for $module\n";
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( $self->is_necessary_dep($module) ) {
                    print "Keeping dep for $module\n";
                    $build_req->{$module} = $meta->{$req}->{$module};
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( $module !~ m{^(CPAN::Meta|CPAN::Meta::Prereqs|Test::Pod|Test::MinimumVersion|Test::MinimumVersion::Fast|Test::PAUSE::Permissions|Test::Spellunker|Test::CPAN::Meta|Software::License|Catalyst|Pod::Coverage::TrustPod|Test::HasVersion|Test::Kwalitee|Test::Pod::Coverage)$} ) {    # Ignore stuff that's probably release testing.
                    $self->dump_self;
                    print "META specified requirement in  $distro  '$module' for '$req' was not detected. Found:\n";
                    $self->cleanup_and_grep($module);
                    printf( "\n        '%s'            => [qw{ %s }],\n", $distro, $module );
                    die;
                }
            }

            # Upgrade the version required if some META specified a version.
            if ( $meta->{$req}->{$module} ) {
                $meta->{$req}->{$module} =~ s/^\s*[><]?=//a;
                $meta->{$req}->{$module} = 0 if !length $meta->{$req}->{$module};                                                                                                                                                                                                                           # If it's a blank string, set it to 0;
                                                                                                                                                                                                                                                                                                            # $meta->{$req}->{$module} += 0; This will corrupt v strings!
                my $meta_version = version->parse( $meta->{$req}->{$module} );
                if ( $meta_version > 0 ) {
                    if ( $build_req->{$module} && version->parse( $build_req->{$module} ) < $meta_version ) {
                        $build_req->{$module} = $meta->{$req}->{$module};
                    }
                }
            }
            delete $meta->{$req}->{$module};
        }

        %{ $meta->{$req} } and die("Modules still listed in req $req");

        $build_json->{$build_req_name} = $build_req;
        delete $meta->{$req};
    }

    # Sometimes we detect a recommends runtime we want to process.
    $build_json->{'recommends_runtime'} = $self->recommends_runtime if %{ $self->recommends_runtime };
    $build_json->{'recommends_build'}   = $self->recommends_build   if %{ $self->recommends_build };
    $build_json->{'conflicts_runtime'}  = $self->conflicts_runtime  if %{ $self->conflicts_runtime };

    # Where this branch got its data from.
    $build_json->{'source'} = 'PAUSE';

    $build_json->{'builder_API_version'} = '1';
    $build_json->{'cant_next'}           = $self->cant_next if $self->cant_next;

    $build_json->{'primary'} or die("Never determined primary module name?");
    $build_json->{'name'} = $meta->{'name'} // $build_json->{'primary'};
    $build_json->{'name'} =~ s/::/-/g;

    delete $meta->{'author'} unless defined $meta->{'author'};    # Remove bogus undefine author.
    if ( $meta->{'author'} ) {
        my $author = $meta->{'author'};
        if ( ref $author eq 'ARRAY' ) {
            $build_json->{'maintainers'} = $author;
        }
        elsif ( !ref $author ) {
            $build_json->{'maintainers'} = [$author];
        }
        delete $meta->{'author'};
    }

    # $meta->{'authored_by'};
    if ( !$build_json->{'maintainers'} && $meta->{'authored_by'} ) {
        $build_json->{'maintainers'} = $meta->{'authored_by'};
    }
    delete $meta->{'authored_by'};

    # Try to read Build.PL or Makefile.PL for the author.
    if ( !$build_json->{'maintainers'} ) {
        my $doc = $self->ppi_cache->{'Build.PL'};
        if ($doc) {
            ( $build_json->{'maintainers'} ) = $self->_ppi_find_and_parse_value_for_key( $doc, 'dist_author' );
        }
        else {
            $doc = $self->ppi_cache->{'Makefile.PL'};
            if ($doc) {
                ( $build_json->{'maintainers'} ) = $self->_ppi_find_and_parse_value_for_key( $doc, 'AUTHOR' );
            }
        }
    }

    if ( !$build_json->{'maintainers'} ) {
        $self->cleanup_and_grep('author|copyright');
        die("Could not determine maintainers for this repo");
    }

    # Verify everything we think we figured out matches META.
    $meta->{'abstract'} && $meta->{'abstract'} =~ s/\r//g;
    if ( length $meta->{'abstract'} && $meta->{'abstract'} ne 'unknown' ) {

        if ( $build_json->{'abstract'} ) {
            $build_json->{'abstract'} eq $meta->{'abstract'} or warn( sprintf( "META abstract does not match what's in the module. I'm going to trust what is in META. meta=%s lib=%s\n", $meta->{'abstract'}, $build_json->{'abstract'} ) );
        }
        $build_json->{'abstract'} = $meta->{'abstract'};
        delete $meta->{'abstract'};
    }
    elsif ( exists $meta->{'abstract'} ) {
        delete $meta->{'abstract'};
    }

    delete $meta->{'provides'}->{'main'};    # Nothing provides main.

    # Validate provides is what we detected
    if ( $meta->{'provides'} ) {
        foreach my $module ( sort { $a cmp $b } keys %{ $meta->{'provides'} } ) {
            $provides->{$module} or die( "Meta provides $module but it was not detected.\n" . Dumper( $meta, $provides ) );

            # Only worry about the meta provides file being right if we didn't have to re-locate it.
            if ( $meta->{'provides'}->{$module}->{'file'} =~ m{^lib/} ) {
                $meta->{'provides'}->{$module}->{'file'} eq $provides->{$module}->{'file'} or die( "Meta provides $module file is not the same as was detected: " . Dumper( $meta, $provides ) );
            }

            # use version.pm to be sure versions don't match if a simple eq doesn't work.
            if ( ( $meta->{'provides'}->{$module}->{'version'} // 0 ) ne ( $provides->{$module}->{'version'} // 0 ) ) {

                # Deal with stupid sprintf VERSIONS: our $VERSION = '0.030.'.sprintf "%04d", (qw($Id: Base.pm 59 2007-04-30 11:24:24Z hacker $))[2];
                if ( $provides->{$module}->{'version'} =~ m/[0-9]\.$/ ) {
                    $provides->{$module}->{'version'} = $meta->{'provides'}->{$module}->{'version'};
                }

                $provides->{$module}->{'version'} =~ s/^vv/v/;           # Fix bug where the version is sometimes vv0.2.2
                $provides->{$module}->{'version'} =~ s/0\.10E0/0.10/;    # Damn it Audrey!

                #printf("%s ne %s\n", $meta->{'provides'}->{$module}->{'version'} // 0,  $provides->{$module}->{'version'} // 0);
                my $detected_version = version->parse( $provides->{$module}->{'version'}           // 0 );
                my $meta_version     = version->parse( $meta->{'provides'}->{$module}->{'version'} // 0 );
                $detected_version == $meta_version or die( "Meta provides $module version ($meta_version) is not the same as was detected ($detected_version): " . $self->dump_self );
            }
            delete $meta->{'provides'}->{$module};
        }
        prune_ref($meta);
    }

    # https://metacpan.org/pod/CPAN::Meta::Spec#keywords (nobody seems to actually use this)
    if ( $meta->{'keywords'} ) {
        $build_json->{'keywords'} = $meta->{'keywords'};
        delete $meta->{'keywords'};
    }

    # https://metacpan.org/pod/CPAN::Meta::Spec#no_index
    # I couldn't determine what we would do with this so it was thrown out.
    if ( $meta->{'no_index'} ) {

        # $build_json->{'no_index'} = $meta->{'no_index'};
        delete $meta->{'no_index'};
    }

    # tells build/test if it should inject . in @INC.
    if ( exists $meta->{'x_use_unsafe_inc'} ) {
        $build_json->{'use_unsafe_inc'} = $meta->{'x_use_unsafe_inc'};
        delete $meta->{'x_use_unsafe_inc'};
    }

    # Validate name detection worked.
    $meta->{'name'} or die( "No name for distro?\n" . Dumper($meta) );
    $meta->{'name'} =~ s/\\?'/-/g;    # Acme::Can't
    $meta->{'name'} =~ s/::/-/g;      # Acme::Can't
    $build_json->{'name'} eq $meta->{'name'} or die( "Bad detection of name?\n" . Dumper( $meta, $build_json ) );
    delete $meta->{'name'};

    # Validate we detected version correctly.
    $meta->{'version'} or die( "No version for distro?\n" . Dumper($meta) );
    $build_json->{'version'} eq $meta->{'version'} or die( "Bad detection of version?\n" . Dumper( $meta, $build_json ) );
    delete $meta->{'version'};

    if ( $build_json->{'builder'} eq 'next' && %$meta ) {
        $self->dump_self;
        die("Unparsed information still exists in dist_meta. Please review.");
    }

    File::Slurper::write_text( $self->BUILD_file, Cpanel::JSON::XS->new->pretty->canonical( [1] )->encode($build_json) );
    $self->git->add( $self->BUILD_file );

    return;
}

sub is_dual_life ( $self, $module ) {
    length $module or return;
    my $v = Module::CoreList->first_release($module);
    return length $v ? 1 : 0;
}

sub merge_dep_into_hash ( $from, $to ) {
    ref $from eq 'HASH' or die ref $from;
    ref $to eq 'HASH'   or die ref $to;

    foreach my $key ( keys %$from ) {
        next if $to->{$key} && $to->{$key} + 0 > $from->{$key} + 0;
        $to->{$key} = $from->{$key};
    }
}

sub prune_ref ($var) {
    my $type = ref $var;
    if ( $type eq 'HASH' ) {
        foreach my $key ( keys %$var ) {
            my $value      = $var->{$key};
            my $value_type = ref $value;
            if ($value_type) {
                prune_ref($value);
            }
            delete $var->{$key} if ( $value_type eq 'ARRAY' && !@{$value} );
            delete $var->{$key} if ( $value_type eq 'HASH'  && !%{$value} );
        }
    }
    return;
}

sub get_ppi_doc ( $self, $filename ) {
    return if $filename =~ m{\.(bak|yml|json|yaml|txt|out|htm|html|tt|tt2|pro|js|css|ps|xml|xhtml|po|mo|tt2|fdb|xsl|xsd|xls|xlsx|csv|tab|jpg|jpeg|png|gif|fla|swf|sql|eye|eyp|doc|docm|ppt|c|cpp|h|dat|zip|gz|tar|jar|java|conf|cfg|ini)$}i;
    return if $filename =~ m{share/|share-module/};                                                                                                                                                                                            # Skip share files. They're not perl code.
    return if $self->is_extra_files_we_ship($filename);

    if ( -l $filename || -d _ || -z _ ) {
        print "$filename isn't a normal file. Skipping PPI parse\n";
        return;
    }

    return $self->ppi_cache->{$filename} if exists $self->ppi_cache->{$filename};

    # print "PPI doc $filename\n";

    state @latin_modules = qw {
      lib/Ananke/Template.pm lib/Ananke/Utils.pm lib/Acme/Flip.pm lib/Acme/HOIGAN.pm lib/Acme/LeetSpeak.pm lib/Acme/Mobile/Therbligs.pm
      lib/Acme/Ukrop.pm lib/Apache/AuthPAM.pm lib/Apache/AuthenLDAP.pm lib/Apache/AuthzCache.pm lib/Apache/NNTPGateway.pm lib/CIPP.pm
      lib/Acme/BOPE.pm
    };

    # Some perl modules have a BOM in the head of their file.
    my $encoding = 'utf8';
    File::BOM::open_bom( my $fh, $filename, ":$encoding" );
    binmode( $fh, ':encoding(Latin1)' ) if grep { $filename eq $_ } @latin_modules;
    binmode( $fh, ':encoding(Latin1)' ) if $filename =~ m{^lib/Event/ExecFlow};

    my $content = '';
    while ( my $line = <$fh> ) {
        if ( $line =~ m/^=encoding\s+(\S+)/ ) {
            my $new_encoding = $1;
            if ( $new_encoding =~ m/^utf-?8\z/i ) {
                $encoding = 'utf8';
            }
            elsif ( $new_encoding =~ m/iso-?8859/i ) {
                $encoding = 'iso-8859';
                last;
            }
            else {
                die("Unknown encoding '$new_encoding'");
            }
        }
        $content .= $line;
    }

    # If we detected a change in encoding,
    if ( $encoding ne 'utf8' ) {
        close $fh;

        if ( $encoding =~ m/iso-?8859/i ) {
            print "Re-open $filename latin1\n";
            open( $fh, '<', $filename );
        }
        else {
            print "Switching encoding to $encoding\n";
            File::BOM::open_bom( $fh, $filename, ":$encoding" );
        }
        $content = do { local $/; <$fh> };
    }

    close $fh;

    my ( $error, $cache );
    {
        local $@;
        $cache = $self->ppi_cache->{$filename} = PPI::Document->new( \$content );
        $error = $@;
    }

    # Fall back to Latin1 (binary) if all attempts to read utf8 or another encoding fail.
    if ( $error =~ m/Malformed UTF-8 character/ ) {
        print "Falling back to binary on $filename. GOT: $error\n";
        File::BOM::open_bom( my $fh, $filename, ":encoding(Latin1)" );
        $content = do { local $/; <$fh> };
        $cache   = $self->ppi_cache->{$filename} = PPI::Document->new( \$content );
    }
    print( "ERR: " . Dumper $@) if $@;

    return $cache;
}

sub _file_to_package ( $filename ) {
    $filename or die;
    $filename =~ s{^lib/}{};
    $filename =~ s{\.(pm|pod)$}{};
    $filename =~ s{/}{::}g;
    return $filename;
}

sub _package_to_file ( $package ) {
    $package or die;
    $package =~ s{::}{/}g;
    $package = "lib/$package.pm";
    return $package;
}

sub is_xt_test ( $self, $filename ) {
    return 0 unless $filename =~ m{^t/.+\.t$};

    my $doc = $self->get_ppi_doc($filename) or return 0;

    return 1 if grep { $_ eq $filename } qw{t/release-distmeta.t t/release-has-version.t t/pod-coverage.t};

    # remove pods
    my $quotes = $doc->find( sub { $_[1]->class =~ m/^PPI::Token::Quote::/ } ) || [];

    # Look for comments about this being an author test.
    foreach my $quote (@$quotes) {
        my $content = $quote->content;
        return 1 if $content =~ m{SKIP these tests are for testing by the author};
        return 1 if $content =~ m{SKIP these tests are for release candidate testing};
    }

    return 0;
}

sub parse_builders_for_share ($self) {
    my $DOTDIRS  = 0;
    my $DOTFILES = 0;
    my @share_directives;

    my $dist   = 0;
    my $module = 0;
    if ( $self->builder_builder eq 'minilla' ) {    # We can just assume minilla is going to support the share dir.
        if ( -d 'share' ) {
            push @share_directives, ['install_share'];
            $dist    = 1;
            $DOTDIRS = $DOTFILES = 1;
        }

    }
    elsif ( $self->builder_builder eq 'Module::Build::Tiny' ) {    # M:B:T wants everything in share/
        if ( -d 'share' ) {
            push @share_directives, ['install_share'];
            $dist    = 1;
            $DOTDIRS = $DOTFILES = 1;
        }
    }
    elsif ( -f 'Build.PL' ) {
        my $doc = $self->get_ppi_doc('Build.PL');
        $doc or die;
        my (@value) = $self->_ppi_find_and_parse_value_for_key( $doc, 'share_dir' );
        if (@value) {
            @value == 1 or die Dumper \@value;
            push @share_directives, [ 'install_share', $value[0] ];
            $DOTDIRS = $DOTFILES = 1;    # M::B doesn't seem to support dropping dot file/dirs.
        }
    }
    elsif ( -e 'Makefile.PL' ) {
        my $doc = $self->get_ppi_doc('Makefile.PL');

        my $sharedir_vars = $doc->find( sub { $_[1]->class eq 'PPI::Token::Symbol' && $_[1]->content =~ m{^\$File::ShareDir::Install::} } ) || [];
        foreach my $sharedir_var (@$sharedir_vars) {
            my ($var) = $sharedir_var->content =~ m/::(INCLUDE_DOT[A-Z]+)$/ or die( $sharedir_var->content );

            my $node = $sharedir_var->snext_sibling;
            $node->class eq 'PPI::Token::Operator' and $node->content eq '=' or die( dump_tree( $sharedir_var->parent, "Unexpected sequence for \$File::ShareDir::Install::" ) );

            $node = $node->snext_sibling;
            $node->class eq 'PPI::Token::Number' or die( dump_tree( $sharedir_var->parent, "Unexpected value for \$File::ShareDir::Install::" ) );

            $DOTDIRS  = $node->content if $var eq 'INCLUDE_DOTDIRS';
            $DOTFILES = $node->content if $var eq 'INCLUDE_DOTFILES';
        }

        # find: install_share dist => "share";
        my $install_shares = $doc->find(
            sub ( $self, $node ) {
                $node->class eq 'PPI::Statement' or return 0;
                my $child = $node->schild(0);
                $child->class eq 'PPI::Token::Word' or return 0;
                $child->content eq 'install_share'  or return 0;
                return 1;
            }
        ) || [];

        foreach my $node (@$install_shares) {
            $node = $node->schild(0);
            my @share_directive = qw/install_share/;
            while ( $node = $node->snext_sibling ) {
                my $content = $node->content;
                my $class   = $node->class;

                next if $class eq 'PPI::Token::Operator';
                last if $class eq 'PPI::Token::Structure' and $content eq ';';

                push @share_directive, strip_quotes( $node->content );
            }
            push @share_directives, [@share_directive];

        }

        # Module::Install doesn't do DOTFILES or DOTDIRS exclusions
        if ( $doc->find( sub ( $self, $node ) { $node->class eq 'PPI::Statement::Include' && $node->content =~ m{inc::Module::Install} } ) ) {
            $DOTDIRS = $DOTFILES = 1;
        }
    }

    foreach my $share (@share_directives) {

        # install_share;
        # install_share dist => "share";
        if ( @$share == 1 or ( @$share == 3 && $share->[1] eq 'dist' && $share->[2] eq 'share' ) ) {
            $dist = 1;
        }

        # install_share "images";
        # install_share dist => 'config';
        elsif ( ( @$share == 3 && $share->[1] eq 'dist' ) or @$share == 2 ) {
            my $share_dist_path = $share->[-1];
            $self->merge_path( $share_dist_path, 'share' );

            $dist = 1;
        }
        elsif ( @$share == 5 && $share->[1] eq 'module' ) {
            my ( undef, undef, $module, $path ) = @$share;
            $module =~ s/::/-/g;
            $self->merge_paths( $path, "share-module/$module" );

            $module = 1;
        }
        else {
            die "Unknown share directive: ", join( " => ", @$share );
        }
    }

    # $DOTDIRS = $DOTFILES = 1;
    # share dir but no share directives. Let's remove share/
    if ( !@share_directives && -d 'share' ) {
        $self->git->rm( '-rf', 'share' );
    }
    elsif (@share_directives) {
        my @share_dirs;
        push @share_dirs, 'share'        if $dist;
        push @share_dirs, 'share-module' if $module;

        if ( !$DOTDIRS ) {
            print "DDD=$DOTDIRS DDF=$DOTFILES\n";
            ...;    # I need a repo that wants this.
            my @dot_dirs_found;
            File::Find::find( sub { next unless -d $_; next unless substr( $_, 0, 1 ) eq '.'; push @dot_dirs_found, $File::Find::name }, @share_dirs );
        }
        if ( !$DOTFILES ) {
            print "DDD=$DOTDIRS DDF=$DOTFILES\n";
            ...;
        }

        # Store the share files so we know to keep them later.
        push @{ $self->share_files }, $self->git->ls_files('share')        if $dist;
        push @{ $self->share_files }, $self->git->ls_files('share-module') if $module;
        $self->reset_repo_files;
    }

    return;
}

sub merge_path ( $self, $from_dir, $to_dir ) {
    return unless -d $from_dir;
    mkpath($to_dir);

    return if $from_dir eq $to_dir;    # no need to move files in share to the share dir.

    my $git = $self->git;

    my @files = map { substr( $_, length($from_dir) + 1 ) } sort { length($b) <=> length($a) } $git->ls_files($from_dir);
    foreach my $file (@files) {
        my $share_path = "$to_dir/$file";

        mkpath($share_path);
        rmdir $share_path;

        $git->mv( '-f', "$from_dir/$file", $share_path );

        my ( undef, $dir, undef ) = File::Spec->splitpath($file);
        rmdir "$from_dir/$dir";
    }
}

sub parse_maker_for_scripts ($self) {

    my $distro  = $self->distro;
    my $scripts = $self->scripts;
    my $meta    = $self->dist_meta;

    # Catfiles that are too hard to parse.
    push @{$scripts}, 'bin/ook'       if $distro eq 'Acme-Ook';
    push @{$scripts}, 'bin/wt'        if $distro eq 'HTTP-WebTest';
    push @{$scripts}, 'bin/mt-upload' if $distro eq 'Net-MovableType';
    push @{$scripts}, 'bin/sys'       if $distro eq 'VCS-SaVeS';
    push @{$scripts}, 'bin/axk'       if $distro eq 'XML-Axk';

    if ( @{$scripts} ) {

        # We had to manually set these. Don't try to read the makers to get the info.
    }

    # NOTE: At the time of writing, we had no evidence that any minil distro did anything other than bin/* and script/*
    elsif ( $self->builder_builder eq 'minilla' ) {

        # This is the default.
        my @files = $self->git->ls_files( 'bin/*', 'script/*' );
        if (@files) {
            push @{$scripts}, @files;
        }
    }
    elsif ( $self->builder_builder eq 'Module::Build::Tiny' ) {

        # This is the default.
        my @files = $self->git->ls_files('script/*');
        if (@files) {
            push @{$scripts}, @files;
        }
    }

    # parse x_provides_scripts to find the scripts this distro ships.
    elsif ( exists $meta->{'x_provides_scripts'} ) {
        if ( ref $meta->{'x_provides_scripts'} eq 'HASH' ) {
            foreach my $provides ( values %{ $meta->{'x_provides_scripts'} } ) {
                ref $provides eq 'HASH' or die( "Unexpected format to x_provides_scripts:\n" . Dumper $meta);
                push @$scripts, $provides->{'file'};
            }
            return;
        }
    }
    elsif ( -e 'Build.PL' ) {
        my $doc = $self->get_ppi_doc('Build.PL');

        push @$scripts, $self->_ppi_find_and_parse_value_for_key( $doc, 'script_files' );

        # https://metacpan.org/pod/Module::Build::API#script_files
        # The default is to install any scripts found in a bin directory at the top level of the distribution, minus any keys of PL_files.
        if ( !@$scripts ) {
            my @files = $self->git->ls_files('bin/*');
            if (@files) {
                push @{$scripts}, @files;
            }
        }
    }
    elsif ( -e 'Makefile.PL' ) {
        my $doc = $self->get_ppi_doc('Makefile.PL');

        # my @scripts = grep {-f } glob("scripts/*.pl "); # Ripped from Text::PDF
        if ( $doc->find( sub ( $self, $node ) { $node->class eq 'PPI::Statement::Variable' && $node->content =~ m{glob\(\s*"scripts/\*\.pl\s*"\)} } ) ) {
            push @$scripts, glob('scripts/*.pl');
            return;
        }

        push @$scripts, $self->_ppi_find_and_parse_value_for_key( $doc, 'EXE_FILES' );
        return if @{$scripts};    # Must be EU::MM cause we got something!

        # Look for Module::Install stuff.
        my $statements = $doc->find( sub { $_[1]->class eq 'PPI::Statement' } ) || [];
        foreach my $statement_node (@$statements) {
            my $node = $statement_node->schild(0);
            $node->class eq 'PPI::Token::Word' && $node->content eq 'install_script' or next;
            $node = $node->snext_sibling;
            $node->class =~ m/^PPI::Token::Quote/ or die( "Unexpected token after install_script: " . Dumper($node) );

            push @$scripts, strip_quotes( $node->content );
        }
    }

    return unless @$scripts;

    # Strip out duplicates.
    @$scripts = uniq(@$scripts);

    my $need_reset = 0;

    my $script_base_dir = 'script';

    # Now we've found the scripts, we want to re-locate them.
    foreach my $script (@$scripts) {
        next if $script =~ m{^$script_base_dir/[^/]+\z};    # bin/abcdef. It's where we want it!
        $script =~ m{^$script_base_dir/} and die("Unexpected $script_base_dir/ path for script: $script");    # bin/foo/bar ?

        mkdir $script_base_dir;                                                                               # just in case it is not there.

        my ( $file, $dirs ) = File::Basename::fileparse($script);

        my $to = "$script_base_dir/$file";
        -e $to and die("Unexpected file relocaing scripts file from $script to $to");

        print "Relocate $script -> $to\n";
        $self->git->mv( $script, $to );
        $script = $to;                                                                                        # We are explicitly altering the alias in the array. (Don't try this at home kids!)

        $need_reset++;
    }

    $self->reset_repo_files if $need_reset;

    return;
}

# Parses the values from:
# 'my_key' => [qw/ abc 123 /], ...
# 'my_key' => ['abc', 123 ], ...

sub _ppi_find_and_parse_value_for_key ( $self, $doc, $key_name ) {
    $doc or die(Carp::longmess);

    my $key_nodes = $doc->find( sub { $_[1]->class =~ m/^PPI::Token::Quote::|^PPI::Token::Word$/ && $_[1]->content =~ m{^['"]?(\Q$key_name\E)['"]?$} } );

    $key_nodes or return;               # Couldn't find anything.
    ref $key_nodes eq 'ARRAY' or die;

    # Verify the next sibling is '=>'
    foreach (@$key_nodes) {
        my $node = $_;

        $node = $node->snext_sibling() or next;    # Not AUTHOR =>
        $node && $node->content eq '=>' or die dump_tree( $key_nodes || $doc, "Unexpected sibling to $key_name" );

        # Next sibling is [] right?
        $node = $node->snext_sibling();
        if ( $node->class eq 'PPI::Structure::Constructor' ) {    # or die( "Unexpected sibling value $key_name: " . dump_tree($node) );
            my @list;
            my ($list_nodes) = $node->schildren;
            $list_nodes or return;                                # Nothing in the list.
            foreach my $list_node ( $list_nodes->children ) {
                next   if $list_node->class eq 'PPI::Token::Operator';
                next   if $list_node->class eq 'PPI::Token::Whitespace';
                return if $list_node->class eq 'PPI::Token::Word';         # Looks like code not a list. Forget it!

                next if $list_node->content =~ m/^\s*qw[\[(]\s*[\])]\s*\z/;    # qw()

                push @list, _ppi_get_list_from_quote_or_quote_like_words($list_node);
            }
            return @list;
        }

        return _ppi_get_list_from_quote_or_quote_like_words($node);
    }

    return;                                                                    # Couldn't find it.
}

sub _ppi_get_list_from_quote_or_quote_like_words ($node) {
    my @list;

    if ( $node->class eq 'PPI::Token::QuoteLike::Words' ) {                    # qw( abc def )
        my $content = $node->content;
        $content =~ s{^qw[\[(/](.*)[)/\]]$}{$1}msi;                            # Strip out qw()
        push @list, split( " ", $content );                                    # magical split on " "
    }
    elsif ( $node->class =~ m{^PPI::Token::Quote::} ) {
        push @list, strip_quotes( $node->content );
    }
    elsif ( $node->class eq 'PPI::Token::Word' ) {
        push @list, $node->content;
    }
    elsif ( $node->class eq 'PPI::Structure::List' ) {                         # [("utils/runDiscovery.pl")],
        $node = $node->schild(0);
        $node->class eq 'PPI::Statement::Expression' or die dump_tree( $node->parent, "Unexpected class for quote/list node" );
        $node = $node->schild(0);
        $node->class =~ m{^PPI::Token::Quote::} or die dump_tree( $node->parent->parent, "Unexpected class for quote/list node" );
        push @list, strip_quotes( $node->content );
        $node = $node->snext_sibling;
        $node and die dump_tree( $node->parent->parent, "Unexpected sequence in quote/list node" );
    }
    else {
        die dump_tree( $node->parent, "Unexpected class for quote/list node" );
    }

    return @list;
}

sub parse_comments ( $self, $filename ) {

    my $doc = $self->get_ppi_doc($filename) or return;

    # remove pods
    my $comments = $doc->find('PPI::Token::Comment') || [];

    # Search for abstract if the file is the primary package
    my $primary_package = $self->BUILD_json->{'primary'};
    if ( $primary_package eq _file_to_package($filename) ) {
        foreach my $comment (@$comments) {
            my $content = $comment->content;
            if ( $content =~ m/^# ABSTRACT:\s+(\S.+$)/ && !$self->BUILD_json->{'abstract'} ) {
                $self->BUILD_json->{'abstract'} = "$1";
                chomp $self->BUILD_json->{'abstract'};
            }
            if ( $content =~ m/under the same terms as Perl itself/msi && !length $self->BUILD_json->{'license'} ) {
                $self->BUILD_json->{'license'} = 'perl';
            }

        }
    }
}

sub parse_pod ( $self, $filename ) {
    return unless $filename =~ m/\.(?:pl|pm|pod)$/i;    # only perl files for pod.

    my $doc = $self->get_ppi_doc($filename) or return;

    my $primary_package = $self->BUILD_json->{'primary'};

    # remove pods
    my $pods = $doc->find('PPI::Token::Pod') || [];

    my $abstract;
    my @author;

    foreach my $pod (@$pods) {
        my @pod_lines = split( "\n", $pod->content );
        while (@pod_lines) {
            my $license_data = '';
            my $line         = shift @pod_lines;

            if ( $line =~ m{^=head1 NAME} ) {
                while ( @pod_lines && $pod_lines[0] && $pod_lines[0] !~ m/^=/ ) {
                    my $line = shift @pod_lines;
                    next unless $line =~ m/^\s*\Q$primary_package\E(?:.pm)?\s+-\s+(.+)/;    # Skip empt
                    $abstract = $1;
                    $abstract =~ s/\s+$//;                                                  # Strip off trailing white space.

                    $self->BUILD_json->{'abstract'} = $abstract;
                    last;
                }
            }
            if ( $line =~ m{^=head[12] AUTHOR} ) {
                while ( @pod_lines && $pod_lines[0] !~ m/^=/ ) {
                    my $line = shift @pod_lines;
                    next unless $line =~ m/\S/;
                    if ( $line =~ m/copyright|terms|disclaimers of warranty|free software|redistribute|itself/i ) {
                        $license_data .= $line;
                        next;
                    }
                    $line =~ s/^\s+//;
                    $line =~ s/\s+\z//;
                    if ( !$self->BUILD_json->{'maintainers'} ) {
                        $self->BUILD_json->{'maintainers'} = \@author;
                    }
                    push @author, $line;
                }
            }
            if ( $line =~ m{^=head[12] CONTRIBUTORS} ) {
                while ( @pod_lines && $pod_lines[0] !~ m/^=/ ) {
                    my $line = shift @pod_lines;
                    next unless $line =~ s/Author:\s*(\S.+)/$1/;
                    if ( !$self->BUILD_json->{'maintainers'} ) {
                        $self->BUILD_json->{'maintainers'} = \@author;
                    }
                    push @author, $line;
                }
            }
            if ( $line =~ m{^=head[12] (COPYRIGHT|LICENSE|LICENCE|LEGALESE)|^=head1 .+ E COPYRIGHT}i ) {

                $self->BUILD_json->{'license'} = 'MIT' if ( $line =~ m/the mit license/i );    # =head1 COPYRIGHT AND LICENSE (The MIT License)

                while ( @pod_lines && $pod_lines[0] !~ m/^=(cut|head)/ ) {
                    my $line = shift @pod_lines;
                    next unless $line =~ m/\S/;
                    $license_data .= " $line";
                }
            }

            $self->parse_text_for_license($license_data);
        }
    }

    return;
}

sub parse_text_for_license ( $self, $license_data ) {

    return unless $license_data;
    return if $self->BUILD_json->{'license'};

    $license_data =~ s/\s\s+/ /msg;    # Strip double spaces to make parsing the text easier.
    $license_data =~ s/\s/ /msg;       # Convert all white space to a single space.

    if ( $license_data =~ m/(or|under) the Artistic License|/msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }
    elsif ( $license_data =~ m/Terms (of|as) Perl itself/msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }                                  # This module is licensed under the same terms as perl itself
    elsif ( $license_data =~ m{same as Perl itself|you can redistribute it and/or modify it under the same terms as the perl 5 programming language system itself|under the same terms as perl\.|is licensed under the same terms as perl itself}msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }
    elsif ( $license_data =~ m/L<perlartistic>/msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }
    elsif ( $license_data =~ m{This distribution is free software; you can redistribute it and/or modify it under the Artistic License 2.0|licensed under: The Artistic License 2.0|artistic_license_2_0}msi ) {
        return $self->BUILD_json->{'license'} = 'Artistic_2_0';
    }
    elsif ( $license_data =~ m/under the terms of the Perl Artistic License/msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }
    elsif ( $license_data =~ m/under the terms of GNU General Public License \(GPL\)/msi ) {
        return $self->BUILD_json->{'license'} = 'GPL';
    }
    elsif ( $license_data =~ m/under the terms of GNU General Public License 3/msi ) {
        return $self->BUILD_json->{'license'} = 'GPLv3+';
    }
    elsif ( $license_data =~ m/MIT License/msi ) {
        return $self->BUILD_json->{'license'} = 'MIT';
    }
    elsif ( $license_data =~ m/the Mozilla Public License Version 1\.1/msi ) {
        return $self->BUILD_json->{'license'} = 'Mozilla_1_1';
    }
    elsif ( $license_data =~ m/under the terms of the Apache 2.0 license/msi ) {
        return $self->BUILD_json->{'license'} = 'Apache_2_0';
    }
    elsif ( $license_data =~ m/L<Software::License::(\S+)>/msi ) {
        return $self->BUILD_json->{'license'} = "$1";
    }
    elsif ( $license_data =~ m/into the public domain|This module is in the public domain/msi ) {
        return $self->BUILD_json->{'license'} = "PublicDomain";
    }

    #die "Unknown license: $license_data==\n";
    return;
}

sub parse_specail_files_for_license ($self) {
    return if $self->BUILD_json->{'license'};

    foreach my $file (qw/README LICENSE COPYING/) {
        next unless -f $file && !-z _;
        my $c = File::Slurper::read_binary($file) || '';
        return if $self->parse_text_for_license($c);
    }

    return;
}

sub parse_code ( $self, $filename ) {
    my $requires_runtime_hash;
    $requires_runtime_hash = $self->requires_build   if $filename =~ m{^t/.+\.(pl|pm|t)$}i;
    $requires_runtime_hash = $self->requires_runtime if $filename =~ m{\.pm$} && $filename !~ m{^t/};
    $requires_runtime_hash = $self->requires_develop if $filename =~ m{^xt/.+\.t$};
    return unless $requires_runtime_hash;    # Doesn't look like perl code we know about.

    my $doc = $self->get_ppi_doc($filename) or return;
    if ( $filename eq 'lib/ACME/QuoteDB/DB/DBI.pm' ) {
        die dump_tree( $doc, "QuoteDB" );
        exit;
    }

    # A list of modules who don't know how to mention a simple version. Serenity NOW!!!
    state $cray_version = {
        'AnyEvent::Handle::Throttle' => '0.000002005',
        'Acme::Version::Hex'         => '0.000976562',
    };

    # find use/require statements and parse them.
    my $use_find = $doc->find('PPI::Statement::Include') || [];
    foreach my $use_node (@$use_find) {
        my (@modules) = _ppi_get_package_usage($use_node) or next;
        $requires_runtime_hash->{$_} = 0 foreach @modules;
    }

    # Moops uses class instead of package *sigh*
    my $moops = exists $requires_runtime_hash->{'Moops'} ? 1 : 0;

    my $primary_module = $self->BUILD_json->{'primary'};

    return unless $filename =~ m{\.(t|pm)$} && $filename =~ m{^(t|lib)/};
    my $provides_hash = ( $filename =~ m/^lib/ ) ? $self->provides : $self->test_provides;

    # Find any DBI->connects.
    my $dbi_nodes = $doc->find(
        sub ( $self, $node ) {
            $node->class eq 'PPI::Token::Word' or return 0;    # DBI
            $node->content eq 'DBI' or return 0;

            $node = $node->snext_sibling;
            $node->class eq 'PPI::Token::Operator' or return 0;    # DBI->
            $node->content eq '->' or return 0;

            $node = $node->snext_sibling;
            $node->class eq 'PPI::Token::Word' or return 0;        # DBI->connect
            $node->content eq 'connect' or return 0;

            return 1;

        }
    ) || [];
    foreach my $dbi_node (@$dbi_nodes) {
        my $c = $dbi_node->snext_sibling->snext_sibling->snext_sibling->content;
        my ($DBD) = $c =~ m/[\"'\(\{]DBI:(\S+):/;
        $requires_runtime_hash->{"DBD::$DBD"} = 0 if length $DBD;
    }

    # Find eval q{ require HTTP::Server::Simple::CGI }
    my $eval_requires = $doc->find(
        sub ( $self, $node ) {
            $node->class eq 'PPI::Statement' or return 0;    # .

            $node = $node->schild(0) or return 0;
            $node->class eq 'PPI::Token::Word' or return 0;    # eval
            $node->content eq 'eval' or return 0;

            $node = $node->snext_sibling;
            $node->class eq 'PPI::Token::Quote::Literal' or return 0;    # eval q{...}

            return 1;

        }
    ) || [];
    foreach my $er (@$eval_requires) {
        my $c = $er->schild(0)->snext_sibling->content;
        my ( $require, $module ) = $c =~ m/(require|use)\s+(\S+)/ or next;

        $module =~ s/;.+\z//msg;                                         # Strip off everything after the ;

        print "Found eval q{ $require $module ...}\n";
        $requires_runtime_hash->{$module} = 0;
    }

    # Find packages that are provides.
    my $packages_find;
    if ($moops) {
        $packages_find = $doc->find( sub ( $self, $node ) { $node->class eq 'PPI::Token::Word' && $node->content eq 'class' || $node->content eq 'library' } ) || [];
    }
    else {
        $packages_find = $doc->find('PPI::Statement::Package') || [];
    }

  PACKAGE: foreach my $pkg_token (@$packages_find) {
        my $module = get_package_provided($pkg_token) or next;

        $provides_hash->{$module}->{'file'}    = $filename;
        $provides_hash->{$module}->{'version'} = 0;

        # Try to detect package foo 1.x {...}
        my $package_braces_version = $pkg_token->schild(0)->snext_sibling->snext_sibling;
        if ( $package_braces_version && $package_braces_version->content ne ';' ) {
            my $number = 0;
            if ( $package_braces_version->class ne 'PPI::Structure::Block' ) {
                $number = ppi_extract_number($package_braces_version);
            }

            $provides_hash->{$module}->{'version'} = $number;
        }

        # Try to determine the VERSION value in each package.
        while ( $pkg_token = $pkg_token->snext_sibling ) {

            #print dump_tree($pkg_token, "NEXT LINE\n");
            my $class = $pkg_token->class;
            last if $class eq 'PPI::Statement::Package';
            next unless $class =~ m/^(PPI::Statement|PPI::Statement::Variable|PPI::Statement::Compound|PPI::Statement::Scheduled)$/;

            my $nodes = $pkg_token->find( sub { ( $_[1]->content eq '$VERSION' | $_[1]->content eq "\$${module}::VERSION" ) && $_[1]->class eq 'PPI::Token::Symbol' } ) or next;
            foreach my $node (@$nodes) {
                my $node = $nodes->[0];
                $node = $node->snext_sibling;
                if ( !ref $node ) {

                    # Possibly ( $VERSION ) = ...
                    eval { $node = $nodes->[0]->parent->parent->snext_sibling };
                    ref $node or die;
                }
                $node->class eq 'PPI::Token::Operator' or next;
                $node->content eq '='                  or next;
                $node = $node->snext_sibling;

                my $version;

                # Try to handle all the stupid things people have done with version lines :(
                if ( $node->class =~ m/^PPI::Token::(Quote|Number)/ ) {
                    $version = $node->content;
                    $version = strip_quotes($version);
                    if ( $version =~ m/Revision: ([0-9.]+)/ ) {    # ( $VERSION ) = '$Revision: 1.9 $ ' =~ /\$Revision:\s+([^\s]+)/;
                        $version = $1;
                        print "Got $module Rev: $version \n";
                    }
                }
                elsif ( $node->class eq 'PPI::Token::Word' && $node->content eq 'qv' ) {    # our $version = qv{v0.0.2}
                    $node = $node->snext_sibling;
                    $node->class eq 'PPI::Structure::List' or die dump_tree( $node, "structure list wrong" );

                    $node = $node->schild(0);
                    $node->class eq 'PPI::Statement::Expression' or die dump_tree( $node, "ppi-sta-express" );

                    $node = $node->schild(0);
                    $node->class =~ m/^(PPI::Token::Quote::|PPI::Token::Number::Version\z)/ or die dump_tree( $node, "PPI::Token::Quote::" );

                    $version = $node->content;
                    $version =~ s/^\s*['"](.+)['"]\s*$/v$1/;                                # Make it a v-string since that's what they were going for.
                    $version =~ s/^vv/v/;                                                   # Sometimes the v is already there. strip off the duplicate.
                }
                elsif ( $node->class eq 'PPI::Token::Word' && $node->content eq 'version' ) {    # our $VERSION = version->.....
                    $node = $node->snext_sibling;                                                # ->
                    $node->class eq 'PPI::Token::Operator' or die dump_tree( $node, "PPI::Token::Operator" );

                    $node = $node->snext_sibling;                                                # declare
                    if ( $node->class eq 'PPI::Token::Word' && $node->content =~ m{^(declare|new)\z} ) {    # our $VERSION = version->declare('v0.2.2');

                        $node = $node->snext_sibling;                                                       # ( ... )
                        $node->class eq 'PPI::Structure::List' or die dump_tree( $node, 'PPI::Structure::List' );

                        $node = $node->schild(0);
                        $node->class eq 'PPI::Statement::Expression' or die dump_tree( $node, 'PPI::Statement::Expression' );

                        $node = $node->schild(0);
                        $node->class =~ m/^PPI::Token::Quote::/ or die dump_tree( $node, '^PPI::Token::Quote::' );

                        $version = $node->content;
                        $version =~ s/^\s*['"](.+)['"]\s*$/v$1/;                                            # Make it a v-string since that's what they were going for.
                    }
                    elsif ( $node->class eq 'PPI::Token::Word' && $node->content eq 'parse' ) {             # our $VERSION = version->parse('v0.2.2')->numify;

                        my $next = $node = $node->snext_sibling;                                            # ( ... )
                        $node->class eq 'PPI::Structure::List' or die dump_tree($node);

                        $node = $node->schild(0);
                        $node->class eq 'PPI::Statement::Expression' or die dump_tree($node);

                        $node = $node->schild(0);
                        $node->class eq 'PPI::Token::Number::Version' or die dump_tree( $nodes->[0]->parent );
                        $version = strip_quotes( $node->content );

                        $node = $next->snext_sibling;
                        $node->class eq 'PPI::Token::Operator' && $node->content eq '->' or die dump_tree( $nodes->[0]->parent );

                        $node = $node->snext_sibling;
                        $node->class eq 'PPI::Token::Word' && $node->content eq 'numify' or die dump_tree( $nodes->[0]->parent );
                        $version = version->parse($version)->numify;
                    }
                    else {
                        die dump_tree( $nodes->[0]->parent, "Failed to parse version-> declaration" );
                    }
                }
                elsif ( $node->class eq 'PPI::Token::Symbol' && $node->content =~ m/"?\$\Q$primary_module\E::VERSION"?$/ ) {    # our $VERSION = $accessors::fast::VERSION;
                    if ( !$provides_hash->{$primary_module} ) {

                        # Most of the time we process the primary module first
                        $self->parse_code( _package_to_file($primary_module) );
                        $provides_hash->{$primary_module} or die("Could not determine a VERSION for primary module $primary_module");
                    }
                    $version = $provides_hash->{$primary_module}->{'version'};
                }
                elsif ( $node->class eq 'PPI::Token::Word' && $node->content eq 'sprintf' ) {                                   # our $VERSION = sprintf "%d.%02d", q$Revision: 0.2 $ =~ /(\d+)/g;
                    my $pkg_token_content = $pkg_token->content;
                    if ( $pkg_token_content =~ m/Revision:\s*([0-9]+\.[0-9]+)\s*\$/ ) {
                        $version = $1;
                    }
                    elsif ( $pkg_token_content =~ m/([0-9.]+)/ ) {
                        $version = $1;
                    }
                    else {
                        die sprintf( "TOKEN (%s=%s): %s--\n", $node->class, $node->content, $pkg_token_content ) . dump_tree( $pkg_token, "Unexpected content in VERSION statement" );
                    }
                }
                elsif ( $pkg_token->content =~ m/Revision:\s*([0-9]+\.[0-9]+)\s*\$/ ) {
                    $version = $1;
                }

                else {
                    #                    my $str = $pkg_token->content;
                    #                    my ($version) = $str =~ m/sprintf.+Revision: ([0-9]+\.[0-9]+)/;

                    #$self->dump_self;
                    #$version or die sprintf( "TOKEN (%s=%s): %s--\n", $node->class, $node->content, $pkg_token->content ) . dump_tree( $pkg_token, "Unexpected content in VERSION statement" );
                }

                # Sometimes we can't trust what we see.
                $version = $cray_version->{$module} // $version // 0;

                print "PROVIDES $module ($version)\n";
                $provides_hash->{$module}->{'version'} = $version;
                next PACKAGE;
            }
        }
    }

}

sub get_package_provided ($element) {
    my $token = $element->first_token;

    $token =~ m/^(package|class)\z/ or die dump_tree( $element, "$token not a package?" );

    # Package statements where the package is on a different line than the package indicates that they are trying to hide it from the PAUSE parser.
    # We're going to do the same.
    $token = $token->next_sibling;
    if ( $token->class eq 'PPI::Token::Whitespace' && $token->content eq "\n" ) {
        print "Skipping detected package '$element' because of new line after package\n";
        return;
    }

    $token = $token->snext_sibling;
    $token and $token->class eq 'PPI::Token::Word' or die dump_tree( $element, "PPTOKWORD" );

    my $package = $token->content;
    $package =~ s/\\?'/::/g;         # Acme::Can't
    return if $package eq 'main';    # main is not a supported package on CPAN.

    print "Found package: $package\n";
    return $package;
}

sub ppi_extract_number ($node) {
    my $class = $node->class;
    return if ( $class eq 'PPI::Token::Structure' );

    if ( $class =~ m{^PPI::Token::Number::} ) {
        return $node->content;
    }

    die dump_tree( $node, "Unexpected data in number node" );

}

sub _ppi_get_package_usage ($element) {
    my $top = $element;

    my $token       = $element->first_token;
    my $require_str = $token->content;
    return if ( $require_str eq 'no' );    # Not an include usually for 'no warnings...'
    $token =~ /^(use|require)$/ or die( dump_tree( $element, "$token not a sub?" ) );
    my $is_use = $1;

    $token = $token->snext_sibling;

    return if ( $token->content =~ m/^5(\.[0-9_]+)?\z/ );    # skip use 5.x and use 5
    if ( $token->content =~ m/[\$\%\@]/ ) {                  # Dynamic require can't be parsed.
        printf( "Failed to parse require: %s\n", $token->content );
        return;
    }

    my $module = $token->content;

    return if $module eq 'main';                             # Main is not a legal CPAN package.

    if ( $module =~ m/^['"]/ ) {                             # require 'AC/protobuf/auth.pl';
        $module = strip_quotes($module);
        return if -e "lib/$module";                          # we don't care if it's just a local file.
    }

    $module =~ s/'/::/g;                                     # Acme::Can't

    # use base 'accessors';
    if ( $is_use eq 'use' and $module =~ /^(base|parent|Test::Requires)$/ ) {
        my @modules = ($1);
        $token = $token->snext_sibling;
        return if $token->class eq 'PPI::Token::Word'      and $token->content eq '-norequire';    # use parent --norequire ...
        return if $token->class eq 'PPI::Token::Structure' and $token->content eq ';';             # use base;

        $token = $token->snext_sibling if ( $token->content eq '+' );                              # use Test::Requires +{ ... };
                                                                                                   # use Test::Requires +{ 'YAML::Tiny' => '1.46' };

        $token = $token->snext_sibling if ( $token->class eq 'PPI::Token::Number::Float' );        # use parent 0.223 "Object::Event"; Just ignore the float number.

        if ( $token->class eq 'PPI::Structure::Constructor' ) {
            $token = $token->schild(0);
            $token->class eq 'PPI::Statement' or die( dump_tree( $token->parent, "unexpected class in Test::Requires requires." ) );
            $token = $token->schild(0);

            $token->class =~ m/^PPI::Token::Quote::|^PPI::Token::Word$/ or die;
            push @modules, strip_quotes( $token->content );
        }
        elsif ( $token->class eq 'PPI::Structure::List' ) {
            $token = $token->schild(0) or return;                                                  # use base (); # Unnecessary code.
            $token->class eq 'PPI::Statement::Expression' or die;
            $token = $token->schild(0);

            push @modules, _ppi_get_list_from_quote_or_quote_like_words($token);

            while ( $token = $token->snext_sibling ) {
                next if $token->class eq 'PPI::Token::Operator';
                push @modules, _ppi_get_list_from_quote_or_quote_like_words($token);
            }

            return @modules;                                                                       # In this case, it's more than one module.
        }
        else {
            push @modules, _ppi_get_list_from_quote_or_quote_like_words($token);
        }

        return @modules;
    }

    # no imports for require.
    return $module if ( $is_use ne 'use' );

    # We need to know if imports are being blocked.
    $token = $token->snext_sibling or die( dump_tree( $top, "Should never happen?" ) );
    if ( $token->class eq 'PPI::Structure::List' && !$token->child(0) ) {
        return ($module);
    }

    # A module is loaded here but it allows imports (BOO!)
    return $module;
}

sub strip_quotes ($string) {
    $string =~ s/^qq?[\[(](.*)[)\]]\z/$1/ms and return $string;
    $string =~ s/^qw[\[(](.*)[\])]\z/$1/ms  and return $string;
    $string =~ s/^(['"])(.*)\1\z/$2/ms      and return $string;
    return $string;
}

sub dump_tree ( $element, $die_msg = '' ) {
    my $dump = PPI::Dumper->new($element);
    print "\n";
    $dump->print;
    return $die_msg ? $die_msg : "WHA WHA";
}

1;
