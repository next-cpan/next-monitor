package Perl::Distro;

use strict;
use warnings;

use FindBin;
use Moose;

use experimental 'signatures';
use experimental 'state';

use version          ();
use Git::Wrapper     ();
use File::Slurper    ();
use File::BOM        ();
use Cwd::Guard       ();
use Cpanel::JSON::XS ();
use CPAN::Meta::YAML ();
use File::Path qw/mkpath/;
use Pod::Markdown::Github ();
use Module::CoreList      ();
use File::Find            ();

use PPI::Document ();
use PPI::Dumper   ();

use Carp;
use Data::Dumper;
$Data::Dumper::Sortkeys = 1;

has 'distro'            => ( isa => 'Str',  is => 'ro', required => 1 );
has 'repo_path'         => ( isa => 'Str',  is => 'ro', required => 1 );
has 'git_binary'        => ( isa => 'Str',  is => 'ro', required => 1 );
has 'push_to_github'    => ( isa => 'Bool', is => 'ro', required => 1 );
has 'clean_dirty_repos' => ( isa => 'Bool', is => 'ro', default  => 1 );

has 'git'       => ( isa => 'Object',  lazy => 1,    is   => 'ro', lazy    => 1, builder => '_build_git' );
has 'dist_meta' => ( isa => 'HashRef', is   => 'rw', lazy => 1,    builder => '_build_meta' );

has 'share_files' => ( isa => 'ArrayRef', is => 'rw', default => sub { return [] } );
has 'repo_files'  => (
    isa     => 'HashRef',
    is      => 'rw',
    lazy    => 1,
    default => sub {
        return { map { ( $_ => 1 ) } shift->git->ls_files };
    }
);

has 'builder_builder' => ( isa => 'Str', is => 'rw', builder => '_build_builder_builder' );

has 'scripts'            => ( isa => 'ArrayRef', is => 'rw', default => sub { return [] } );
has 'requires_build'     => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'requires_runtime'   => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'requires_develop'   => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'recommends_build'   => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'recommends_runtime' => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'conflicts_runtime'  => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'provides'           => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );
has 'test_provides'      => ( isa => 'HashRef',  is => 'rw', default => sub { return {} } );

has 'ppi_cache' => ( isa => 'HashRef', is => 'rw', default => sub { return {} } );

has 'BUILD_json' => ( isa => 'HashRef', is => 'rw', default => sub { return {} } );
has 'BUILD_file' => ( isa => 'Str',     is => 'rw', default => 'BUILD.json' );

sub _build_builder_builder ($self) {
    return 'minilla' if -f 'minil.toml' && !-z _;
    return 'dzil'    if -f 'dist.ini'   && !-z _;
    if ( -f 'Build.PL' ) {
        my $c = $self->try_to_read_file('Build.PL');
        if ( $c =~ m/THIS FILE IS AUTOMATICALLY GENERATED BY MINILLA/msi ) {
            return 'minilla';
        }

        if ( $c =~ m/Module::Build::SysPath/msi ) {
            return 'Module::Build::SysPath';
        }
    }

    return '';
}

sub _build_git ($self) {
    return Git::Wrapper->new( { 'dir' => $self->repo_path, 'git_binary' => $self->git_binary } ) || die( 'Failed to create Git::Wrapper for ' . $self->repo_path );
}

sub _build_meta ($self) {

    if ( -f 'META.json' ) {
        return Cpanel::JSON::XS::decode_json( File::Slurper::read_binary('META.json') );
    }
    if ( -f 'META.yml' ) {
        my $txt  = $self->try_to_read_file('META.yml');
        my $yaml = CPAN::Meta::YAML->read_string($txt);
        return $yaml->[0] if $yaml && ref $yaml eq 'CPAN::Meta::YAML';
    }
    if ( -f 'Makefile.PL' ) {    # Generate MYMETA.json?
        `$^X Makefile.PL`;
        if ( -e 'MYMETA.json' ) {
            my $json = Cpanel::JSON::XS::decode_json( File::Slurper::read_binary('MYMETA.json') );
            $self->git->clean('-dxf');
            return $json;
        }
    }

    die( 'No META data found in ' . $self->distro . "\n" . `ls -l` . "\n\n" . Carp::longmess );
}

sub dump_self ($self) {
    $self->ppi_cache( {} );
    print Dumper $self;

    return '';
}

sub is_play ($self) {
    return $self->BUILD_json->{'builder'} eq 'play';
}

sub do_the_do ($self) {
    $self->check_if_dirty_and_die;
    $self->checkout_p5_branch;

    my @log = $self->git->log(qw/p5..PAUSE/);

    # Has the PAUSE branch been updated since p5 was last merged from it?
    if (@log) {    # Reset the branch to its state on the current PAUSE branch and re-process it.
        my $git = $self->git;
        eval { $git->merge('PAUSE') };    # This will probably fail but that's ok.
        $self->delete_all_repo_files;
        my $bin = $self->git_binary;
        `$bin archive PAUSE | /usr/bin/tar -x`;
        $self->git->add( '-f', '.' );
    }
    elsif ( -e $self->BUILD_file ) {
        print "Nothing to update\n";

        # There are no new changes and BUILD.yaml has already been created.
        return;
    }

    $self->fix_special_repos;
    $self->determine_installer;
    $self->parse_specail_files_for_license;

    if ( $self->distro ne 'Alien-Win32-LZMA' && $self->distro =~ m/^Alien-/ && $self->is_play ) {
        $self->dump_self;
        my $distro = $self->distro;
        die("Somehow we didn't detect that   $distro   couldn't play.");
    }

    if ( $self->is_play ) {
        $self->parse_maker_for_scripts;
        $self->parse_builders_for_share;
        $self->cleanup_tree;
        $self->update_p5_branch_from_PAUSE;
    }
    else {
        $self->determine_primary_module;

        # Try to parse the POD
        my $primary = $self->find_non_play_primary;
        $self->gather_non_play_provides_from_meta;
        $self->parse_pod($primary) if $primary;

        $self->generate_build_json;
    }

    $self->git_commit;
}

sub delete_all_repo_files ($self) {
    my $git = $self->git;

    my @files = eval { $git->ls_files };
    return unless @files;

    # remove any files and check if we succeed.
    eval { $git->rm( '-f', @files ) };
    eval { @files = $git->ls_files };
    return unless @files;

    # If we still have files, try to do it one at a time.
    foreach my $file (@files) {
        $git->rm( '-f', $file );
    }

    # fail if there are still files at this point.
    @files = $git->ls_files;
    @files and die( sprintf( "Unexpected files could not be deleted from %s repo: %s", $self->distro, Dumper \@files ) );

    return;
}

sub gather_non_play_provides_from_meta ($self) {
    my $meta = $self->dist_meta;
    return unless $meta->{'provides'};

    my $provides = $self->provides;

    foreach my $module ( sort { $a cmp $b } keys %{ $meta->{'provides'} } ) {
        $provides->{$module}->{'file'}    = $meta->{'provides'}->{$module}->{'file'};
        $provides->{$module}->{'version'} = $meta->{'provides'}->{$module}->{'version'} // 0;
    }
}

# This is only done in the event the module isn't play and we need to look around for it.
sub find_non_play_primary ($self) {
    my @parts    = split( "::", $self->BUILD_json->{'primary'} );
    my $lib_path = join( "/", 'lib', @parts ) . ".pm";
    return $lib_path if -f $lib_path;

    print "no $lib_path\n";

    my $no_lib = $parts[-1] . ".pm";
    return $no_lib if -f $no_lib;

    print "no $no_lib\n";

    return;
}

sub check_if_dirty_and_die ($self) {
    my $git = $self->git;
    my $st  = $git->status;
    return unless $st->is_dirty;

    my $txt = '';
    foreach my $status (qw/indexed changed unknown/) {
        my @status = $st->get($status) or next;
        my $type   = $status eq 'unknown' ? 'Untracked' :    #
          $status eq 'changed' ? 'Changes not staged' :      #
          'Changes to be committed';                         #
        $txt .= "$type: \n";
        foreach my $s (@status) {
            $txt .= sprintf( "  - %s\n", $s->from );
        }
    }

    if ( $self->clean_dirty_repos ) {
        eval { $git->merge('--abort') };                     # In case we were in the middle of a merge.
        $git->reset('.');
        $git->clean('-dxf');
        $git->checkout('.');
    }
    else {
        my $repo_path = $self->git->dir;
        die("\nThe repo $repo_path is unexpectedly dirty. Please correct this:\n$txt\n");
    }

    return;
}

sub checkout_p5_branch ($self) {
    my $git = $self->git;

    my @branches = eval { $git->branch };

    # the p5 branch is already there. Just switch to it.
    if ( grep { $_ =~ m/^\s*\*?\s+p5\z/ } @branches ) {
        eval { $git->checkout( '-f', 'p5' ) };
        return;
    }

    # All of this only needs to happen if we don't have a local p5 branch already.

    eval { $git->fetch('origin') };
    @branches = eval { $git->branch('-a') };

    # If the remote exists for some reason, let's check out the remote and track it.
    if ( grep { $_ =~ m{^\s*remotes/origin/p5\z} } @branches ) {
        eval { $git->checkout(qw{-t origin/p5}) };
        @branches = eval { $git->branch };

        # the p5 branch is now there.
        return if grep { $_ =~ m/^\s*\*\s+p5\z/ } @branches;
        die( "Could not checkout p5 branch from upstream in repo: " . $git->dir );
    }

    # We haven't generated the p5 branch yet. we need to fork it from PAUSE.

    # Make sure there's a PAUSE branch.
    if ( !grep { $_ =~ m/^\s*\*?\s+PAUSE\z/ } @branches ) {
        die( "Cannot create a p5 branch because PAUSE is missing for repo " . $git->dir );
    }

    $git->checkout(qw{-b p5});
    $git->reset(qw{--hard PAUSE});
    $git->push(qw{--set-upstream origin p5}) if $self->push_to_github;
}

sub is_unnecessary_dep ( $self, $module ) {
    my $distro = $self->distro;

    # Play does File::ShareDir::Install by itself.
    return 1 if $module eq 'File::ShareDir::Install' && $self->is_play;

    state $skips = {
        'Acme-CPANModules-CalculatingDayOfWeek'   => [qw{ Bencher::Backend }],
        'Acme-CPANModules-TextTable'              => [qw{ Bencher::Backend }],
        'Acme-MetaSyntactic-chinese_zodiac'       => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-christmas'            => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-countries'            => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-dangdut'              => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-display_resolution'   => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-frasier'              => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-id_names'             => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-nethack'              => [qw{ File::Find::Rule }],
        'Acme-MetaSyntactic-seinfeld'             => [qw{ Test::MetaSyntactic }],
        'Acme-MetaSyntactic-vim'                  => [qw{ File::Find::Rule }],
        'Acme-YAPC-Asia-2012-LTthon-Hakushu'      => [qw{ Test::Requires }],
        'Algorithm-BinPack-2D'                    => [qw{ Test::Requires }],
        'Algorithm-TravelingSalesman-BitonicTour' => [qw{ Pod::Coverage }],
        'Algorithm-VectorClocks'                  => [qw{ Test::NoWarnings }],
        'Alien-libgeos'                           => [qw{ Test::Deep }],

    };

    return unless $skips->{$distro};
    return 1 if grep { $_ eq $module } @{ $skips->{$distro} };
    return 0;
}

sub is_necessary_dep ( $self, $module ) {
    my $distro = $self->distro;

    state $keeps = {
        'AI-PredictionClient'            => [qw{ Inline::CPP Inline::MakeMaker }],    # hard to parse Inline use statement to detect Inline::CPP.
        'Acme-MathProfessor-RandomPrime' => [qw{Test::NoWarnings}],
    };

    return unless $keeps->{$distro};
    return 1 if grep { $_ eq $module } @{ $keeps->{$distro} };
    return 0;
}

sub fix_special_repos ( $self ) {

    my $distro = $self->distro;

    $self->git->mv( glob('PGPSign/*'), '.' ) if ( $distro eq 'Acme-PGPSign' );
    $self->git->mv( glob('RTB/*'),     '.' ) if ( $distro eq 'Acme-RTB' );
    $self->git->mv( glob('Stegano/*'), '.' ) if ( $distro eq 'Acme-Stegano' );
    $self->git->rm( '-rf', 'local' ) if ( $distro eq 'Acme-Sort-Sleep' );
    $self->git->mv( glob('Line/Bresenham/C/*'), '.' ) if ( $distro eq 'Algorithm-Line-Bresenham-C' );

    state $incorrect_case_files = {
        qw{
          makefile.pl Makefile.PL
          meta.json META.json
          meta.yml META.yml
          manifest MANIFEST
          readme README
          }
    };

    # Correct case insensitive files to the right case.
    foreach my $bad_file ( keys %$incorrect_case_files ) {
        next if !-e $bad_file;
        next if -e $incorrect_case_files->{$bad_file};
        $self->git->mv( $bad_file, $incorrect_case_files->{$bad_file} );
    }

    # Distro doesn't match the file.
    $self->parse_pod('Ace.pm') if $distro eq 'AcePerl';

    $self->BUILD_json->{'maintainers'} = 'Cal Henderson, <cal@iamcal.com>'       if $distro =~ /^(Acme-Goatse|Acme-OneBit)$/;
    $self->BUILD_json->{'maintainers'} = 'Audrey Tang <cpan@audreyt.org>.'       if $distro eq 'Acme-Hello';
    $self->BUILD_json->{'maintainers'} = 'Paul Fenwick.'                         if $distro eq 'Acme-OSDc';
    $self->BUILD_json->{'maintainers'} = 'David Nicol.'                          if $distro eq 'Acme-landmine';
    $self->BUILD_json->{'maintainers'} = 'Salvador Fandino <sfandino@yahoo.com>' if $distro eq 'Algorithm-ClusterPoints';

    # Repos where their tarball doesn't match their primary module.
    state $repos_to_rename = {
        'AI-Classifier-Text'                => 1,
        'AIX-LPP-lpp_name'                  => 1,
        'Algorithm-DependencySolver-Solver' => 1,
        'Alvis-URLs'                        => 1,
    };

    if ( $repos_to_rename->{$distro} ) {
        $self->dist_meta->{'name'} = $distro;
    }

    $self->BUILD_json->{'license'} = 'unknown' if grep { $distro eq $_ } qw{ Acme-Code-FreedomFighter ACME-Error-Translate Acme-ESP Acme-Goatse AFS AFS-Command AI-Fuzzy AI-General AIS-client AIX-LPP-lpp_name
      Acme-Lingua-Strine-Perl Acme-ManekiNeko Acme-Method-CaseInsensitive Acme-Remote-Strangulation-Protocol Acme-Turing Acme-URM Acme-Ukrop Acme-Void Algorithm-FEC Alien-KentSrc Alien-MeCab Alien-HDF4 Alien-Iconv
      Alien-Saxon
    };
    $self->BUILD_json->{'license'} = 'perl' if grep { $distro eq $_ } qw{ ACME-Error-31337 ACME-Error-IgpayAtinlay Acme-OSDc Acme-PM-Berlin-Meetings Acme-please Algorithm-Cluster};
    $self->BUILD_json->{'license'} = 'GPL'  if grep { $distro eq $_ } qw{ AI-LibNeural };

    state $files_to_delete = {
        'Acme-Aheui'                                => [qw{bin/aheui}],
        'Acme-BeCool'                               => [qw{example.pm}],
        'Acme-Beatnik'                              => [qw{findwords.pl generate.pl}],
        'Acme-Blarghy-McBlarghBlargh'               => [qw{blarghymcblarghblargh.pl}],
        'Acme-Buckaroo'                             => [qw{retest.txt}],
        'Acme-Buffy'                                => [qw{buffy}],
        'Acme-CPAN-Testers-UNKNOWN'                 => [qw{messup.PL}],
        'Acme-CPANAuthors-Acme-CPANAuthors-Authors' => [qw{scripts/author_info.pl scripts/basic_info.pl}],
        'Acme-Cow-Interpreter'                      => ['bin/*'],
        'Test-Unit'                                 => [ 'TestRunner.pl', 'TkTestRunner.pl' ],
        'Acme-CPANAuthors-AnyEvent'                 => [qw{script/AnyEvent.tt script/generate.pl}],
        'Acme-CPANAuthors-DualLife'                 => [qw{tools/duallife.pl}],
        'Acme-CPANAuthors-GitHub'                   => [qw{scripts/generate-github-authors.pl}],
        'Acme-CPANAuthors-Japanese'                 => [qw{bin/unregistered_japanese_authors}],
        'Acme-CPANAuthors-MBTI'                     => [qw{authorlists/* misc/*}],
        'Acme-CPANAuthors-Russian'                  => [qw{script/cpan-author.pl script/cpan-faces.pl}],
        'Acme-CreatingCPANModules'                  => [qw{images/* slides/*}],
        'Acme-Curses-Marquee'                       => [qw{scrolly}],
        'Acme-Dahut-Call'                           => [qw{demo/synopsis.pl}],
        'Acme-EvaTitlenize'                         => [qw{bin/eva-titlenize}],
        'Acme-EyeDrops'                             => [qw{demo/findshapes.pl demo/gentable.pl demo/sightly.pl xBuild.PL}],
        'Acme-Filter-Kenny'                         => [qw{bin/kennyfy}],
        'Acme-Flat'                                 => [qw{misc/Changes.deps misc/Changes.deps.all misc/Changes.deps.dev misc/Changes.deps.opt misc/built_with.json misc/perlcritic.deps}],
        'Acme-Futuristic-Perl'                      => [qw{COPYRIGHT}],
        'Acme-Geo-Whitwell-Name'                    => [qw{demo/zip_to_whitwell}],
        'Acme-Glue'                                 => [qw{snippets/LEEJO/hopscotch.p6 snippets/LEEJO/transform.pl snippets/SLU/MAZE.BAS snippets/SLU/schwartzian_transform.pl}],
        'ADAMK-Release'                             => [qw{script/adamk-release share/LICENSE share/MANIFEST.SKIP share/pmv.t share/pod.t}],
        'AFS-Command'                               => [qw{COPYRIGHT}],
        'AI-Categorizer'                            => [qw{doc/classes-overview.png doc/classes.png}],
        'AI-Evolve-Befunge'                         => [qw{example.conf}],
        'AI-MXNetCAPI'                              => [qw{mxnet.i mxnet_typemaps.i}],
        'AI-NaiveBayes'                             => [qw{a}],
        'AI-NeuralNet-BackProp'                     => [qw{docs.htm}],
        'AI-NeuralNet-Mesh'                         => [qw{mesh.htm}],
        'AI-PSO'                                    => [qw{MPL-1.1.txt extradoc/ReactivePower-PSO-wks.pdf}],
        'AI-Pathfinding-OptimizeMultiple'           => [qw{bin/optimize-game-ai-multi-tasking rejects.pod}],
        'AI-Prolog'                                 => [qw{data/sleepy.pro data/spider.pro}],
        'AI-XGBoost'                                => [qw{misc/using_capi.c}],
        'AIX-LPP-lpp_name'                          => [qw{data/lpp_name scripts/mkcontrol}],
        'Acme-Gosub'                                => [qw{scripts/bump-version-number.pl scripts/tag-release.pl}],
        'Acme-Hodor'                                => [qw{unhodor.pl}],
        'Acme-JTM-Experiment'                       => [qw{AUTHOR_PLEDGE CODE_OF_CONDUCT.md}],
        'Acme-Jungle-CrawlerExample'                => [qw{data/sample}],
        'Acme-KeyboardMarathon'                     => [qw{marathon.pl source-tree-marathon.pl}],
        'Acme-Lambda-Expr'                          => [qw{tool/operators.pl}],
        'Acme-MITHALDU-XSGrabBag'                   => [qw{README.PATCHING}],
        'Acme-Mahjong-Rule-CC'                      => [qw{mj_series}],
        'Acme-MetaSyntactic-legoindianajones'       => [qw{indie.txt}],
        'Acme-MorningMusume-ShinMember'             => [qw{bin/genmusume}],
        'Acme-Ook'                                  => [qw{ook/*.ook}],
        'Acme-PIA-Export'                           => [qw{Acme-PIA-Export-0.019.html}],
        'Acme-Pinoko'                               => [qw{benchmark/pinoko_vs_geso.pl}],
        'Acme-PriPara'                              => [qw{etc/90_concept.t}],
        'Acme-RandomEmoji'                          => [qw{author/RandomEmoji.pm author/generate.pl author/screenshot.png}],
        'Acme-Resume'                               => [qw{iller.yaml}],
        'Acme-RunDoc'                               => [qw{FAQ foo.pl foo2.pl word-examples/helloworld.doc word-lib/Hello/World.docm}],
        'Acme-Signum'                               => [qw{signum.pl}],
        'Acme-Test-LocaleTextDomain'                => [qw{LocaleData/id/LC_MESSAGES/Acme-Test-LocaleTextDomain.mo po/Acme-Test-LocaleTextDomain.pot po/id.po}],
        'Acme-Test-LocaleTextDomainIfEnv'           => [qw{LocaleData/id/LC_MESSAGES/Acme-Test-LocaleTextDomainIfEnv.mo po/Acme-Test-LocaleTextDomainIfEnv.pot po/id.po}],
        'Acme-Test-LocaleTextDomainUTF8IfEnv'       => [qw{LocaleData/id/LC_MESSAGES/Acme-Test-LocaleTextDomainUTF8IfEnv.mo po/Acme-Test-LocaleTextDomainUTF8IfEnv.pot po/id.po}],
        'Acme-Text-Rhombus'                         => [qw{scripts/print-rhombus.pl}],
        'Acme-Time-Asparagus'                       => [qw{VERSION}],
        'Acme-Time-Constant'                        => [qw{misc/Changes.deps misc/Changes.deps.all misc/Changes.deps.dev misc/Changes.deps.opt misc/built_with.json misc/perlcritic.deps}],
        'Acme-XSS'                                  => [qw{xss.html}],
        'Acme-rafl-Everywhere'                      => [qw{a.pl changes.patch}],
        'Activiti-Rest-Client'                      => [qw{test/*}],
        'Agent-TCLI'                                => [qw{bin/agent_tail.pl}],
        'Agent-TCLI-Package-Net'                    => [qw{bin/agent_net.pl}],
        'Album'                                     => [qw{helper/Makefile helper/README helper/autorun.inf helper/shellrun.c helper/shellrun.exe script/album}],
        'Algorithm-BitVector'                       => [qw{Examples/BitVectorDemo.pl Examples/README Examples/testinput.txt}],
        'Algorithm-CheckDigits'                     => [qw{cgi-bin/checkdigits.cgi}],
        'Algorithm-CouponCode'                      => [qw{html/cc_icons.png html/index.html html/jquery.couponcode.css html/jquery.couponcode.js html/style.css}],
        'Algorithm-CurveFit-Simple'                 => [qw{data/hra-bhn.tsv}],
        'Algorithm-DecisionTree'                    => [qw{Examples/* ExamplesBagging/* ExamplesBoosting/* ExamplesRandomizedTrees/* ExamplesRegression/*}],
        'Algorithm-Diff'                            => [qw{cdiff.pl diff.pl diffnew.pl htmldiff.pl}],
        'Algorithm-Evolutionary-Simple'             => [qw{script/bitflip.pl script/onemax-benchmark.pl script/xover.pl}],
        'Algorithm-FloodControl'                    => [qw{svn-commit.tmp}],
        'Algorithm-GenerateSequence'                => [qw{bench_call}],
        'Algorithm-Hamming-Perl'                    => [qw{example01 example02 example03 example04}],
        'Algorithm-HowSimilar'                      => [qw{html/HowSimilar.html html/docs.css}],
        'Algorithm-LCSS'                            => [qw{html/LCSS.html html/docs.css}],
        'Algorithm-MarkovChain'                     => [qw{demos/dada demos/empty demos/textfile}],
        'Algorithm-MasterMind'                      => [qw{app/evorank.yaml app/mm-eda.cgi app/process_experiment.pl app/run_experiment.pl app/run_experiment_all.pl}],
        'Algorithm-Paxos'                           => [qw{docs/paxos-simple.pdf}],
        'Algorithm-SAT-Backtracking'                => [qw{b/0-or.b b/1-xor.b b/2-and.b b/3-or-xor.b}],
        'Algorithm-Tree-NCA'                        => [qw{Release e/execution.log e/timing.pl}],
        'Alien-BWIPP'                               => [qw{AUTHORS}],
        'CPAN-Unwind'                               => [qw{adm/podok}],
        'Perl-Maker'                                => [qw{share/Makefile.tt share/perl-maker.yaml}],
        'Reflex'                                    => [qw{bench.pl bench/* docs/*}],
        'AMF-Perl'                                  => [qw{doc/*}],
        'AOL-TOC'                                   => [qw{tocbot/*}],
        'AOLserver-CtrlPort'                        => [qw{adm/.cvsignore adm/MANIFEST.SKIP adm/release}],
        'AlignDB-DeltaG'                            => [qw{dump/dG.yml dump/dump_dG.pl}],
        'Alt-Data-Frame-ButMore'                    => [qw{TODO.otl data-raw/* utils/*}],
        'Alvis-Pipeline'                            => [qw{bin/README etc/db/alvis.xml etc/db/xml-core.xml}],
        'Alzabo-Display-SWF'                        => [qw{etc/Tahoma-B.fdb etc/Tahoma.fdb etc/Verdana-B.fdb etc/Verdana.fdb etc/create.pl etc/my_conf.yml}],
        'Amazon-Dash-Button'                        => [qw{systemctl/Makefile systemctl/amazon-dash-button.service}],

    };

    if ( $files_to_delete->{$distro} ) {
        $self->git->rm( '-f', @{ $files_to_delete->{$distro} } );
    }

    # Remove vim .swp files.
    my @files = $self->git->ls_files('*.swp');
    if (@files) {
        $self->git->rm( '-f', @files );
    }
}

sub _remove_files_by_pattern ( $self, $pattern ) {
    my $files = $self->repo_files;
    foreach my $file ( keys %$files ) {
        next unless $file =~ $pattern;
        delete $files->{$file};
        $self->git->rm( '-f', $file );
    }

    return;
}

sub cleanup_tree ($self) {
    my $git   = $self->git;
    my $files = $self->repo_files;

    $self->dist_meta;    # Make sure we initialize META data in memory before removing the files.
    my $distro = $self->distro;

    # Delete garbage files we don't want.
    foreach my $unwanted_file (
        qw{ MANIFEST MANIFEST.SKIP MANIFEST.bak MANIFEST.skip INSTALL INSTALL.pod INSTALL.txt INSTALL.skip INSTALL.SKIP INSTALL.Debian SIGNATURE dist.ini Makefile.PL Build.PL weaver.ini
        README README.md README.pod README.txt README.markdown README.html README.old
        BUGS META.yml META.json ignore.txt .gitignore .mailmap Changes.PL cpanfile cpanfile.snapshot minil.toml .cvsignore .travis.yml travis.yml appveyor.yml .appveyor.yml
        .project t/boilerplate.t MYMETA.json MYMETA.yml Makefile Makefile.old maint/Makefile.PL.include metamerge.json README.bak dist.ini.bak
        AUTHORS
        CREDITS doap.ttl author_test.sh cpants.pl makeall.sh perlcritic.rc .perltidyrc .perltidy dist.ini.meta Changes.new Changes.old
        CONTRIBUTORS tidyall.ini perlcriticrc perltidyrc README.mkdn .shipit example.pl pm_to_blib
        install.txt install.sh install.cmd install.bat .settings/org.eclipse.core.resources.prefs .includepath META.ttl Makefile.PL.back
        Artistic_License.txt GPL_License.txt LICENSE.txt LICENSE.GPL LICENSE.Artistic misc/make_manifest.pl GPL.txt
        }
    ) {
        next unless $files->{$unwanted_file};
        delete $files->{$unwanted_file};
        $git->rm( '-f', $unwanted_file );
    }

    # Throw out repo tarballs.
    $self->_remove_files_by_pattern(qr{^\Q$distro\E-.+\.tar\.gz$});

    # Throw out maint/cip- files. Not sure what they are.
    $self->_remove_files_by_pattern(qr{^maint/(cip-|release)});

    # Throw out meta/*.pret
    $self->_remove_files_by_pattern(qr{/.+\.pret$});

    # Throw out repo directories
    $self->_remove_files_by_pattern(qr{^\.(svn|hg)/|/\.(svn|hg)/});

    # Get rid of directories we don't want.
    $self->_remove_files_by_pattern(qr{^(?:inc|samples|Samples|demo|debian|tools|benchmark|devdata|devscript|devscripts|_build|maint|ubuntu-)/});

    # *~ or /#file# (emacs backups)
    $self->_remove_files_by_pattern(qr{~$|/#.+#$|^#.+#$});

    # Normalize all TODO files to 'Todo' and throw out the boilerplate ones.
    my @todo = sort grep { $_ =~ m/^todo(.md)?$/i } keys %$files;
    if (@todo) {
        scalar @todo == 1 or die( "Too many TODO files.\n" . Dumper($files) );
        my $todo = shift @todo;
        if ( $todo ne 'Todo' ) {
            delete $files->{$todo};
            $files->{'Todo'} = 1;
            $git->mv( $todo, 'Todo' );
        }

        # See if the TODO is worthless.
        my $content = $self->try_to_read_file('Todo');
        if ( $content =~ m/- Nothing yet/ms ) {
            $git->rm( '-f', 'Todo' );
            delete $files->{'Todo'};
        }
    }

    # Deal with unneeded debian COPYRIGHT file.
    if ( $files->{'COPYRIGHT'} && $files->{'LICENSE'} ) {
        open( my $fh, '<', 'COPYRIGHT' ) or die("Can't read COPYRIGHT: $!");
        my $line = <$fh>;
        if ( $line =~ m/^Format: http.+debian/ ) {
            close $fh;
            $git->rm('COPYRIGHT');
            delete $files->{'COPYRIGHT'};
        }
    }

    # Alternative license files. LICENCE
    foreach my $license_variant (qw/COPYRIGHT LICENCE COPYING/) {
        next unless $files->{$license_variant};
        $files->{'LICENSE'} and die("Unexpectedly found LICENSE and $license_variant in the same distro");

        $git->mv( $license_variant, 'LICENSE' );

        $files->{'LICENSE'} = 1;
        delete $files->{$license_variant};
    }

    # Normalize all Changelog files to a common 'Changelog'
    foreach my $contrib_variant (qw{CONTRIBUTING CONTRIBUTING.mkdn docs/SubmittingPatches.pod}) {
        next unless $files->{$contrib_variant};

        $files->{'Changelog'} && die("Unexpectedly saw CONTRIBUTING.md and $contrib_variant in the same repo. I don't know what to do");

        print "Renaming $contrib_variant to CONTRIBUTING.md\n";
        $git->mv( $contrib_variant, 'CONTRIBUTING.md' );
        delete $files->{$contrib_variant};
        $files->{'CONTRIBUTING.md'} = 1;
        last;    # We can't move 2 files to the same destination so this will fail later.
    }

    # Normalize all Changelog files to a common 'Changelog'
    foreach my $changes_variant (qw/CHANGES CHANGELOG Changes ChangeLog/) {
        next unless $files->{$changes_variant};

        $files->{'Changelog'} && die("Unexpectedly saw Changelog and $changes_variant in the same repo. I don't know what to do");

        print "Renaming $changes_variant to Changelog\n";
        $git->mv( $changes_variant, 'Changelog' );
        delete $files->{$changes_variant};
        $files->{'Changelog'} = 1;
        last;    # We can't move 2 files to the same destination so this will fail later.
    }

    # Re-locate t/ test files that belong in xt/
    foreach my $file ( sort { $a cmp $b } keys %$files ) {
        next unless $self->is_xt_test($file);

        print "Moving $file to xt/\n";

        mkdir('xt');
        $git->mv( $file, 'xt/' );

        # update the files hash.
        delete $files->{$file};
        $file =~ s{^t/}{xt/};
        $files->{$file} = 1;
    }

    # Move test.pl into t/test_pl.t
    if ( -f 'test.pl' ) {
        mkdir 't';
        -e 't/test_pl.t' and die("Unexpected test.pl / test_pl.t combo??");
        $git->mv( 'test.pl', 't/test_pl.t' );
        delete $files->{'test.pl'};
        $files->{'t/test_pl.t'} = 1;
    }

    return;
}

sub reset_repo_files ($self) {
    $self->repo_files( { map { ( $_ => 1 ) } $self->git->ls_files } );
}

sub determine_primary_module ($self) {
    my $git        = $self->git;
    my $distro     = $self->distro;
    my $build_json = $self->BUILD_json;
    my $meta       = $self->dist_meta;
    my $files      = $self->repo_files;

    # Try to determine the primary package of this distro.
    # Let's make sure it matches the 'name' of the module.
    $build_json->{'primary'} = $meta->{'name'};
    $build_json->{'primary'} =~ s/-/::/g;
    $build_json->{'primary'} =~ s/\\?'/::/g;    # Acme::Can't

    return unless $self->is_play;               # We shouldn't alter the location of the module if we're not a play module.

    # Move the module into lib/ if we need to.
    my @module      = split( '::', $build_json->{'primary'} );
    my $module_path = join( '/', ( 'lib', @module ) ) . ".pm";

    if ( !-d 'lib' && -d $module[0] ) {
        printf( "Moving root name space (%s) into lib/\n", $module[0] );
        mkdir 'lib';
        $git->mv( $module[0], 'lib/' );

        # There's no easy way to update $self->repo_files. We're going to have to re-scan it.
        $self->reset_repo_files;
        $files = $self->repo_files;
    }

    if ( !$files->{$module_path} ) {

        my $filename = $module[-1] . ".pm";
        if ( $files->{$filename} ) {
            print "Primary module $module_path is in the wrong place. It is being moved.\n";
            mkpath($module_path);
            rmdir $module_path;
            $git->mv( $filename, $module_path );

            delete $files->{$filename};
            $files->{$module_path} = 1;
        }

        # Possibly the submodules also need to be moved.
        my $dir_path = join( '/', ( 'lib', @module ) );
        my $dir      = $module[-1];
        if ( -d $dir && !-d $dir_path ) {
            print "Detected submodules in the wrong place. Moving those too.\n";
            $git->mv( $dir, $dir_path );

            # There's no easy way to update $self->repo_files. We're going to have to re-scan it.
            $self->reset_repo_files;
            $files = $self->repo_files;
        }
    }

    if ( !-f $module_path ) {
        $self->dump_self;
        die("Can't find $module_path");
    }

    return;
}

sub update_p5_branch_to_not_play ($self) {
    my $build_json = $self->BUILD_json;
    my $meta       = $self->dist_meta;
    $build_json->{'version'} = $meta->{'version'};
    $self->determine_primary_module;
}

sub is_extra_files_we_ship ( $self, $file ) {

    # Explicit files we're going to ignore.
    return 1 if ( grep { $file eq $_ } qw/Changelog LICENSE CONTRIBUTING.md Todo author.yml/ );

    # paths with example files we're going to ignore.
    return 1 if $file =~ m{^(eg|examples?|ex)/};

    my $distro = $self->distro;

    # Wierd files for specific distros.
    return 1 if $file =~ m{^proto\b} && $distro =~ m/^AC-/;
    return 1 if $file =~ m{^fortune/}          && $distro eq 'Acme-24';
    return 1 if $file =~ m{^Roms/}             && $distro eq 'Acme-6502';
    return 1 if $file =~ m{^ascii-art\.pl$}    && $distro eq 'Acme-AsciiArtinator';
    return 1 if $file =~ m{^demo/|unbleach.pl} && $distro eq 'Acme-Bleach';
    return 1 if $file =~ m{^testlib/}          && $distro eq 'abbreviation';
    return 1 if $file eq 'acmelsd.png'    && $distro eq 'Acme-LSD';
    return 1 if $file eq 'OSDc/prog.osdc' && $distro eq 'Acme-OSDc';
    return 1 if $file eq 'test.txt'       && $distro eq 'Acme-Stegano';
    return 1 if $file eq 'sqltest.lib'    && $distro eq 'AlignDB-SQL';
    return 1 if $distro eq 'Alvis-TermTagger' and grep { $_ eq $file } qw{ bin/TermTagger-brat.pl bin/TermTagger.pl etc/corpus-test-lem.txt etc/corpus-test.txt etc/termlist-test.lst };

    return 0;
}

sub cleanup_and_grep ( $self, $grep ) {
    $self->git->reset('.');
    $self->git->checkout('.');
    $self->git->clean('-dxf');
    print "Grep:\n";
    print `git grep -iP '$grep'`;
}

# We can assume we are checked out into the p5 branch but it is
# Indeterminate if PAUSE has merged in or if the p5 branch has been
# converted.
sub update_p5_branch_from_PAUSE ($self) {
    my $git        = $self->git;
    my $distro     = $self->distro;
    my $build_json = $self->BUILD_json;
    my $meta       = $self->dist_meta;

    $build_json->{'XS'} and die("play doesn't support XS distros");

    $self->determine_primary_module;

    # If test paths are specified in META, transfer that unless they're just t/* or t/*.t.
    if ( $meta->{'tests'} ) {
        my $tests = $meta->{'tests'};
        delete $meta->{'tests'};
        if ( $tests !~ m{^t/*\S+$} ) {
            $build_json->{'tests'} = [ map { $_ .= ".t" if m/\*$/; $_ } split( " ", $tests ) ];
        }
    }

    my $files = $self->repo_files;
    foreach my $file ( sort { $a cmp $b } keys %$files ) {
        $self->parse_code($file);
        $self->parse_comments($file);
        $self->parse_pod($file);
    }

    {    #  Look for any unexpected files in the file list.
        my %files_copy = %{ $self->repo_files };

        foreach my $script ( @{ $self->scripts } ) {
            $build_json->{'scripts'} ||= [];

            push @{ $build_json->{'scripts'} }, $script;
            delete $files_copy{$script};
        }

        #Anything in lib, t, xt is good. Just pass it through.
        delete $files_copy{$_} foreach grep { m{^lib/|^t/|^xt/} } keys %$files;

        # Files we know are ok, we'll delete from the hash.
        foreach my $file ( sort keys %files_copy ) {
            delete $files_copy{$file} if $self->is_extra_files_we_ship($file);
        }

        # Detected share files.
        foreach my $file ( @{ $self->share_files } ) {
            delete $files_copy{$file};
        }

        # Nothing was found.
        #         'Acme-CPANAuthors-GitHub'                 => [qw{scripts/generate-github-authors.pl}],
        if (%files_copy) {
            my @unexpected_files = sort { $a cmp $b } keys %files_copy;
            printf( "Unexpected files found in    %s\n%s\n", $distro, Dumper( \%files_copy ) );
            my $grep = join( '|', @unexpected_files );
            $self->cleanup_and_grep($grep);
            printf( "\n        '%s'                 => [qw{%s}],\n", $distro, join( " ", @unexpected_files ) );
            die;
        }
    }

    $self->generate_build_json;

    {    # Generate README.md from the primary module.
        $self->BUILD_json->{'provides'}->{ $self->BUILD_json->{'primary'} }->{'file'} or die( "Unexpected primary file location not found:\n" . Dumper $self->BUILD_json );
        my $primary_file = $self->BUILD_json->{'provides'}->{ $self->BUILD_json->{'primary'} }->{'file'};

        my $primary_file_stem = $primary_file;
        $primary_file_stem =~ s/\.pm$//;
        $primary_file = -e "$primary_file_stem.pod" ? "$primary_file_stem.pod" : $primary_file;

        my $markdown;
        my $parser = Pod::Markdown::Github->new;
        $parser->unaccept_targets(qw( html ));
        $parser->output_string( \$markdown );
        $parser->parse_string_document( $self->try_to_read_file($primary_file) );
        File::Slurper::write_text( 'README.md', $markdown );
        -f 'README.md' && !-z _ or die("Couldn't generate README.md");

        $git->add('README.md');
    }

    return;
}

sub try_to_read_file ( $self, $filename ) {
    -f $filename or return;
    -z _ and return '';

    local $@;
    my $contents;
    eval { $contents = File::Slurper::read_text($filename); 1 } and return $contents;
    print "Trying latin 1 on $filename\n";
    eval { $contents = File::Slurper::read_binary($filename); 1 } and return $contents;
    die("Could not parse $filename: $@");
}

sub git_commit ($self) {
    my $git = $self->git;

    $git->commit( '-m', sprintf( "Update %s version %s to play.", $self->distro, $self->BUILD_json->{'version'} ) );

    $git->push if $self->push_to_github;

    return;
}

sub determine_installer ( $self ) {
    my $build_json = $self->BUILD_json;
    my $files      = $self->repo_files;
    my $distro     = $self->distro;

    my $builder = 'play';

    # Tag the BUILD file with whether this repo has XS.
    if ( grep { $_ =~ m/\.xs(.inc)?$/ } keys %$files ) {
        $build_json->{'XS'} = 1;
        $builder = 'legacy';
        print "Detected .xs files in distro\n";
    }
    else {
        $build_json->{'XS'} = 0;
    }

    $builder = 'legacy' if $distro =~ m/^(Acme-Padre-PlayCode|Alien-TALib)$/;

    # .PL files usually indicate something that needs to be generated.
    my @files;
    if ( @files = grep { $_ =~ m/\.PL$/ && $_ !~ m/^(Build|Makefile)\.PL$/ } keys %$files ) {
        printf( "Detected %s files which indicate a dynamic generation which can't play yet!\n", join( ", ", @files ) );
        $builder = 'legacy';
    }

    # This isn't really a builder builder but since we had the file open we detected
    # that it doesn't really support play right now.
    if ( $self->builder_builder eq 'Module::Build::SysPath' ) {
        $builder = 'legacy';
    }

    # These modules customize the default Maker in a way we can't simulate.
    my @banned_modules = qw/Alien::Base Inline::C Inline::CPP Alien::Build Alien::autoconf Alien::m4 Alien::automake Alien::libtool FFI::Build::MM/;
    my $meta           = $self->dist_meta;
    my @exceptions;
    if ( $meta->{'prereqs'} && ref $meta->{'prereqs'} eq 'HASH' ) {
        foreach my $prereq ( values %{ $meta->{'prereqs'} } ) {
            next unless @exceptions = grep { defined $prereq->{'requires'}->{$_} } @banned_modules;
            $builder = 'legacy';
            printf( "The Build/install modules (%s) make the installer unable to play.\n", join( ", ", @exceptions ) );
            last;
        }
    }
    foreach my $meta_requires (qw/configure_requires build_requires requires test_requires/) {
        next unless ref $meta->{$meta_requires} eq 'HASH';
        next unless @exceptions = grep { defined $meta->{$meta_requires}->{$_} } @banned_modules;
        $builder = 'legacy';
        printf( "The Build/install modules (%s) make the installer unable to play.\n", join( ", ", @exceptions ) );
        last;
    }

    $builder = 'legacy' if defined $meta->{'requires'}->{'Alien::Base'};
    $builder = 'legacy' if defined $meta->{'configure_requires'}->{'Alien::Base'};

    # Validate x_static_install matches our own decision.
    if ( defined $meta->{'x_static_install'} ) {
        if ( $meta->{'x_static_install'} ) {
            $builder eq 'play' or die('x_static_install says this distro is static but I detected things that might make it legacy');
        }
        else {
            $builder eq 'legacy' or warn(q{x_static_install says this distro isn't static but I don't know why it is play at this point?});
            $builder = 'legacy';
            print "Detected x_static_install=1\n";
        }
        delete $meta->{'x_static_install'};
    }

    if ( $builder ne 'legacy' and -e 'Build.PL' ) {

        if ( $builder ne 'legacy' ) {
            my @found = eval { $self->git->grep('ACTION_install') };
            if (@found) {
                print "Build.PL distro is using ACTION_install somewhere. Cannot play.\n";
                $builder = 'legacy';
            }
        }

        my $content = $self->try_to_read_file('Build.PL');

        if ( $content =~ m/(My::Builder\S+)/msi ) {
            print "Custom build logic found in Build.PL: $1\n";
            $builder = 'legacy';
        }
        elsif ( $content =~ m/Module::Build->subclass/ms ) {
            print "Build.PL is subclassing so it must be doing something wierd. Skipping play.\n";
            $builder = 'legacy';
        }
        elsif ( $content =~ m/add_build_element/ms ) {
            print "Build.PL is using add_build_element. Skipping play.\n";
            $builder = 'legacy';
        }
        elsif ( $distro =~ m/^Alien-/ && $content =~ m/use lib [^;]*inc/ ) {
            print "Alien module via Build.PL is using inc/. I suspect it can't play\n";
            $builder = 'legacy';
        }
        elsif ( $content =~ m/use\s+ExtUtils::Liblist/ ) {
            print "Build.PL is using ExtUtils::Liblist. Can't play!\n";
            $builder = 'legacy';
        }
        elsif ( $content =~ m/install_path/msi ) {
            print "Build.PL is using install_path. Can't play!\n";
            $builder = 'legacy';
        }

        if ( $builder ne 'legacy' and $content =~ m/sys_files/msi ) {
            print "Need to implement support for install_path, sys_files in Build.PL";
            ...;
            $builder = 'legacy';
        }
        if ( $builder ne 'legacy' ) {

            # die("Undetected legacy");
        }

        # Parse Build.PL for install_path or sys_files and ban the use of the module.
    }

    # No XS but maybe OBJECTS is mentioned in Makefile.PL?
    if ( $builder ne 'legacy' and -f 'Makefile.PL' ) {
        my $doc = $self->get_ppi_doc('Makefile.PL');
        my ($object) = $self->_ppi_find_and_parse_value_for_key( $doc, 'OBJECT' );
        $object = strip_quotes($object) if length $object;
        if ( length $object ) {
            $builder = 'legacy';
            printf( "Detected a legacy build due to OBJECT => %s in Makefile.PL\n", $object );
        }
        elsif ( $self->_ppi_find_class_and_content( $doc, 'PPI::Token::Word', 'postamble' ) ) {
            $builder = 'legacy';
            printf("Detected a postamble in Makefile.PL. Something can't be installed with play.\n");
        }
        elsif ( $self->_ppi_find_class_and_content( $doc, 'PPI::Token::Word', 'prompt_script' ) ) {
            $builder = 'legacy';
            printf("Detected a M::I prompt_script  in Makefile.PL. Something can't be installed with play.\n");
        }
        elsif ( $distro =~ m/^Alien-/ and $self->_ppi_find_class_and_content( $doc, 'PPI::Token::QuoteLike::Backtick', qr/`/ ) ) {
            $builder = 'legacy';
            printf("Makefile.PL uses backticks.\n");
        }
        else {
            #die; dump_tree($doc);
        }

        #        if($builder eq 'play') { die dump_tree($doc, "postamble stuff.") }
    }

    # Force the cache on maker files. Often we need to peek back at the makers and we remove them early.
    foreach my $builder (qw/Build.PL Makefile.PL/) {
        next unless -f $builder && !-z _;
        $self->get_ppi_doc($builder);
    }

    # If the builder is play, then set it and return.
    if ( $builder eq 'play' ) {
        $build_json->{'builder'} = 'play';
        return;
    }

    # Guess based on what builder to use based on files in the repo.
    $build_json->{'builder'} = $files->{'Build.PL'} ? 'Build.PL' : $files->{'Makefile.PL'} ? 'Makefile.PL' : die("Can't determine builder for distro $distro");
    return;
}

# $self->_ppi_find_class_and_content( $doc, 'PPI::Token::QuoteLike::Backtick', qr/`/
# $self->_ppi_find_class_and_content( $doc, 'PPI::Token::Word', 'prompt_script'

sub _ppi_find_class_and_content ( $self, $doc, $class, $content ) {

    return $doc->find(
        sub ( $self, $node ) {
            if ( ref $class ) {
                $node->class =~ $class or return 0;
            }
            else {
                $node->class eq $class or return 0;
            }

            if ( ref $content ) {
                $node->content =~ $content or return 0;
            }
            else {
                $node->content eq $content or return 0;
            }
            return 1;
        }
    );
}

sub parse_license_file ($self) {
    my $files = $self->repo_files;
    return unless $files->{'LICENSE'};
    my $content = $self->try_to_read_file('LICENSE');

    return 'perl' if $content =~ m/Terms\s*(of|as)\s*Perl\s*itself/msi;
    return 'MIT'  if $content =~ m/The MIT Licens/msi;
    return;

}

sub generate_build_json ($self) {
    my $build_json = $self->BUILD_json;
    my $meta       = $self->dist_meta;
    my $distro     = $self->distro;

    $build_json->{'version'} = $meta->{'version'};

    # Sometimes the meta license isn't just a string. Let's normalize it.
    if ( ref $meta->{'license'} eq 'ARRAY' ) {
        $meta->{'license'} = join( ", ", @{ $meta->{'license'} } );
    }
    ref $meta->{'license'} and die( "Unexpected meta license data: " . Dumper $meta);

    # unknown isn't a valid license except when it is.
    # We have a few distros which truly don't have a meaningful license.
    if ( $meta->{'license'} && $meta->{'license'} eq 'unknown' ) {
        if ( $build_json->{'primary'} !~ m{^(ACL::Regex)$} ) {
            delete $meta->{'license'};
        }
    }

    # Use the meta license preferentially if it's there.
    if ( $meta->{'license'} ) {
        $build_json->{'license'} = $meta->{'license'};
    }

    # Last attempt try reading LICENSE
    if ( !$build_json->{'license'} ) {
        $build_json->{'license'} = $self->parse_license_file;
        if ( !$build_json->{'license'} ) {
            $self->dump_self;
            printf( "Missing license for   %s\n\n", $self->distro );
            $self->cleanup_and_grep('license|copyright');
            die;
        }
    }

    if ( %{ $self->provides } ) {
        $build_json->{'provides'} = $self->provides;
    }

    # Decode the resource urls. These have been inconsistently stored over the years.
    foreach my $resource (qw/bugtracker repository/) {
        next unless $meta->{'resources'}->{$resource};
        my $value = $meta->{'resources'}->{$resource};

        my $value_ref = ref $value;
        $value = !$value_ref ? $value : $value_ref eq 'HASH' ? $value->{'web'} : die( "Unexpected resources structure for $resource:\n" . Dumper( $meta->{'resources'} ) );

        $build_json->{$resource} = $value;
    }

    # unused vars in meta.
    delete $meta->{$_} foreach (
        qw/dynamic_config generated_by meta-spec x_generated_by_perl x_serialization_backend license resources x_deprecated
        release_status x_Dist_Zilla x_authority distribution_type installdirs version_from x_contributors x_spdx_expression
        x_test_requires x_authority_from_module x_permissions_from_module x_BuiltWith module_name x_contributor_covenant
        x_provides_scripts/
    );
    foreach my $prereq_key (qw/configure build runtime test develop/) {
        next unless $meta->{'prereqs'};
        next unless $meta->{'prereqs'}->{$prereq_key};
        next unless $meta->{'prereqs'}->{$prereq_key}->{'requires'};

        if ( $prereq_key eq 'configure' ) {
            $meta->{'configure_requires'} ||= {};
            merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'requires'}, $meta->{'configure_requires'} );
            foreach my $extra_cfg (qw/recommends suggests/) {
                if ( $meta->{'prereqs'}->{$prereq_key}->{$extra_cfg} ) {
                    merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{$extra_cfg}, $self->recommends_build );
                    delete $meta->{'prereqs'}->{$prereq_key}->{$extra_cfg};
                }
            }
        }
        if ( $prereq_key eq 'runtime' ) {
            $meta->{'requires'} ||= {};
            merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'requires'}, $meta->{'requires'} );

            if ( $meta->{'prereqs'}->{$prereq_key}->{'recommends'} ) {
                merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'recommends'}, $self->recommends_runtime );
                delete $meta->{'prereqs'}->{$prereq_key}->{'recommends'};
            }
            if ( $meta->{'prereqs'}->{$prereq_key}->{'suggests'} ) {
                merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'suggests'}, $self->recommends_runtime );
                delete $meta->{'prereqs'}->{$prereq_key}->{'suggests'};
            }
            if ( $meta->{'prereqs'}->{$prereq_key}->{'conflicts'} ) {
                merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'conflicts'}, $self->conflicts_runtime );
                delete $meta->{'prereqs'}->{$prereq_key}->{'conflicts'};
            }
        }
        if ( $prereq_key eq 'test' || $prereq_key eq 'build' ) {
            $meta->{'build_requires'} ||= {};
            merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'requires'}, $meta->{'build_requires'} );
            if ( $meta->{'prereqs'}->{$prereq_key}->{'recommends'} ) {
                merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'recommends'}, $self->recommends_build );
                delete $meta->{'prereqs'}->{$prereq_key}->{'recommends'};
            }
            if ( $meta->{'prereqs'}->{$prereq_key}->{'suggests'} ) {
                merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'suggests'}, $self->recommends_build );
                delete $meta->{'prereqs'}->{$prereq_key}->{'suggests'};
            }
        }
        if ( $prereq_key eq 'develop' ) {
            $meta->{'develop_requires'} ||= {};
            merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{'requires'}, $meta->{'develop_requires'} );
            foreach my $extra_dev (qw/recommends suggests/) {
                if ( $meta->{'prereqs'}->{$prereq_key}->{$extra_dev} ) {
                    merge_dep_into_hash( $meta->{'prereqs'}->{$prereq_key}->{$extra_dev}, $meta->{'develop_requires'} );
                    delete $meta->{'prereqs'}->{$prereq_key}->{$extra_dev};
                }
            }
            foreach my $additional_key ( keys %{ $meta->{'prereqs'}->{$prereq_key} } ) {
                next unless $additional_key =~ m/^x_/;
                print "Deleting develop prereq section $additional_key\n";
                delete $meta->{'prereqs'}->{$prereq_key}->{$additional_key};
            }
        }

        delete $meta->{'prereqs'}->{$prereq_key}->{'requires'};
        prune_ref( $meta->{'prereqs'}->{$prereq_key} );

        keys %{ $meta->{'prereqs'}->{$prereq_key} } and die( "Unexpected prereqs found in $prereq_key:\n" . Dumper $meta);
    }
    foreach my $prereq_key ( grep { m/^x_/ } keys %{ $meta->{'prereqs'} } ) {
        print "Deleting non-standard prereq section $prereq_key\n";
        delete $meta->{'prereqs'}->{$prereq_key};
    }

    prune_ref($meta);
    $meta->{'prereqs'} and die( "Unexpected prereqs found:\n" . Dumper $meta);

    my $provides      = $self->provides;
    my $test_provides = $self->test_provides;
    foreach my $req ( $self->requires_build, $self->requires_runtime, $self->requires_develop ) {
        foreach my $module ( keys %$req ) {
            delete $req->{$module} if $provides->{$module} or $test_provides->{$module};
        }
    }

    # Merge in detected requires_runtime into BUILD.yaml. Validate against META as we go.
    foreach my $req (qw/requires recommends build_requires test_requires configure_requires develop_requires/) {
        my $build_req_name =
            $req eq 'requires'           ? 'requires_runtime'
          : $req eq 'recommends'         ? 'recommends_runtime'
          : $req eq 'build_requires'     ? 'requires_build'
          : $req eq 'configure_requires' ? 'requires_build'
          : $req eq 'test_requires'      ? 'requires_build'
          : $req eq 'develop_requires'   ? 'requires_develop'
          :                                die("Unknown req $req");

        my $build_req = $self->$build_req_name;

        foreach my $module ( keys %{ $meta->{$req} } ) {

            # Skip specifying our own modules in require sections.
            if ( $provides->{$module} ) {
                delete $meta->{$req}->{$module};
                next;
            }

            # These requirements never move over to p5.
            if ( $module =~ m/^(?:ExtUtils::MakeMaker|Module::Build|App::ModuleBuildTiny|Module::Build::Tiny|(inc::)?Module::Install|Module::Build::Pluggable(?:::.+)?|ExtUtils::MakeMaker::CPANfile|Module::Install|strict|warnings|version|lib)$/ ) {
                delete $meta->{$req}->{$module};
                next;
            }

            # special handling for minimum perl version.
            if ( $module eq 'perl' ) {
                $build_req->{$module} = $meta->{$req}->{$module};
                delete $meta->{$req}->{$module};
                next;
            }

            # Let's not be so strict on develop requires. Maybe they know what they're talking about.
            # Also who cares? play doesn't use develop_requires right now.
            if ( !exists $build_req->{$module} && $req eq 'develop_requires' ) {
                $build_req->{$module} = $meta->{$req}->{$module};
                delete $meta->{$req}->{$module};
                next;
            }

            # Add a recommends section.
            if ( !exists $build_req->{$module} && $req eq 'requires' ) {
                $build_req->{$module} = $meta->{$req}->{$module};
                delete $meta->{$req}->{$module};
                next;
            }

            if ( !exists $build_req->{$module} ) {
                if ( !$self->is_play or $req eq 'recommends' ) {    # Just pass it through.
                    $build_req->{$module} = $meta->{$req}->{$module};
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( ( grep { $req eq $_ } qw/configure_requires test_requires build_requires/ ) && exists $self->requires_runtime->{$module} ) {    # ignore build stage requires if runtime requires it.
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( $self->is_dual_life($module) ) {
                    $build_req->{$module} = $meta->{$req}->{$module};
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( $self->is_unnecessary_dep($module) ) {
                    print "Skipping dep for $module\n";
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( $self->is_necessary_dep($module) ) {
                    print "Keeping dep for $module\n";
                    $build_req->{$module} = $meta->{$req}->{$module};
                    delete $meta->{$req}->{$module};
                    next;
                }
                elsif ( $module !~ m{^(CPAN::Meta|CPAN::Meta::Prereqs|Test::Pod|Test::MinimumVersion|Test::MinimumVersion::Fast|Test::PAUSE::Permissions|Test::Spellunker|Test::CPAN::Meta|Software::License|Catalyst|Pod::Coverage::TrustPod|Test::HasVersion|Test::Kwalitee|Test::Pod::Coverage)$} ) {    # Ignore stuff that's probably release testing.
                    $self->dump_self;
                    print "META specified requirement in  $distro  '$module' for '$req' was not detected. Found:\n";
                    $self->cleanup_and_grep($module);
                    printf( "\n        '%s'            => [qw{ %s }],\n", $distro, $module );
                    die;
                }
            }

            # Upgrade the version required if some META specified a version.
            if ( $meta->{$req}->{$module} ) {
                $meta->{$req}->{$module} =~ s/[><]?=\s*//;
                my $meta_version = version->parse( $meta->{$req}->{$module} );
                if ( $meta_version > 0 ) {
                    if ( $build_req->{$module} && version->parse( $build_req->{$module} ) < $meta_version ) {
                        $build_req->{$module} = $meta->{$req}->{$module};
                    }
                }
            }
            delete $meta->{$req}->{$module};
        }

        %{ $meta->{$req} } and die("Modules still listed in req $req");

        $build_json->{$build_req_name} = $build_req;
        delete $meta->{$req};
    }

    # Sometimes we detect a recommends runtime we want to process.
    $build_json->{'recommends_runtime'} = $self->recommends_runtime if %{ $self->recommends_runtime };
    $build_json->{'recommends_build'}   = $self->recommends_build   if %{ $self->recommends_build };
    $build_json->{'conflicts_runtime'}  = $self->conflicts_runtime  if %{ $self->conflicts_runtime };

    # Where this branch got its data from.
    $build_json->{'source'} = 'PAUSE';

    $build_json->{'builder_API_version'} = '1';

    $build_json->{'primary'} or die("Never determined primary module name?");
    $build_json->{'name'} = $build_json->{'primary'};
    $build_json->{'name'} =~ s/::/-/g;

    delete $meta->{'author'} unless defined $meta->{'author'};    # Remove bogus undefine author.
    if ( $meta->{'author'} ) {
        my $author = $meta->{'author'};
        if ( ref $author eq 'ARRAY' ) {
            $build_json->{'maintainers'} = $author;
        }
        elsif ( !ref $author ) {
            $build_json->{'maintainers'} = [$author];
        }
        delete $meta->{'author'};
    }
    if ( !$build_json->{'maintainers'} ) {
        my $makedoc = $self->ppi_cache->{'Makefile.PL'};
        if ($makedoc) {
            ( $build_json->{'maintainers'} ) = $self->_ppi_find_and_parse_value_for_key( $makedoc, 'AUTHOR' );
        }
    }

    if ( !$build_json->{'maintainers'} ) {
        $self->cleanup_and_grep('author|copyright');
        die("Could not determine maintainers for this repo");
    }

    # Verify everything we think we figured out matches META.
    if ( length $meta->{'abstract'} && $meta->{'abstract'} ne 'unknown' ) {

        if ( $build_json->{'abstract'} ) {
            $build_json->{'abstract'} eq $meta->{'abstract'} or warn( sprintf( "META abstract does not match what's in the module. I'm going to trust what is in META. meta=%s lib=%s\n", $meta->{'abstract'}, $build_json->{'abstract'} ) );
        }
        $build_json->{'abstract'} = $meta->{'abstract'};
        delete $meta->{'abstract'};
    }
    elsif ( exists $meta->{'abstract'} ) {
        delete $meta->{'abstract'};
    }

    # This module doesn't use packages. let's just copy provides over.
    $provides = $meta->{'provides'} if $distro eq 'Acme-Resume';
    delete $meta->{'provides'}->{'Acme::XSSism'} if $distro eq 'Acme-XSS';

    # Validate provides is what we detected
    if ( $meta->{'provides'} ) {
        foreach my $module ( sort { $a cmp $b } keys %{ $meta->{'provides'} } ) {
            $provides->{$module} or die( "Meta provides $module but it was not detected.\n" . Dumper( $meta, $provides ) );

            # Only worry about the meta provides file being right if we didn't have to re-locate it.
            if ( $meta->{'provides'}->{$module}->{'file'} =~ m{^lib/} ) {
                $meta->{'provides'}->{$module}->{'file'} eq $provides->{$module}->{'file'} or die( "Meta provides $module file is not the same as was detected: " . Dumper( $meta, $provides ) );
            }

            # use version.pm to be sure versions don't match if a simple eq doesn't work.
            if ( ( $meta->{'provides'}->{$module}->{'version'} // 0 ) ne ( $provides->{$module}->{'version'} // 0 ) ) {

                # Deal with stupid sprintf VERSIONS: our $VERSION = '0.030.'.sprintf "%04d", (qw($Id: Base.pm 59 2007-04-30 11:24:24Z hacker $))[2];
                if ( $provides->{$module}->{'version'} =~ m/[0-9]\.$/ ) {
                    $provides->{$module}->{'version'} = $meta->{'provides'}->{$module}->{'version'};
                }
                my $detected_version = version->parse( $provides->{$module}->{'version'}           // 0 );
                my $meta_version     = version->parse( $meta->{'provides'}->{$module}->{'version'} // 0 );
                $detected_version == $meta_version or die( "Meta provides $module version ($meta_version) is not the same as was detected ($detected_version): " . $self->dump_self );
            }
            delete $meta->{'provides'}->{$module};
        }
        prune_ref($meta);
    }

    # https://metacpan.org/pod/CPAN::Meta::Spec#keywords (nobody seems to actually use this)
    if ( $meta->{'keywords'} ) {
        $build_json->{'keywords'} = $meta->{'keywords'};
        delete $meta->{'keywords'};
    }

    # https://metacpan.org/pod/CPAN::Meta::Spec#no_index
    if ( $meta->{'no_index'} ) {
        $build_json->{'no_index'} = $meta->{'no_index'};
        delete $meta->{'no_index'};
    }

    # tells build/test if it should inject . in @INC.
    if ( exists $meta->{'x_use_unsafe_inc'} ) {
        $build_json->{'use_unsafe_inc'} = $meta->{'x_use_unsafe_inc'};
        delete $meta->{'x_use_unsafe_inc'};
    }

    # Validate name detection worked.
    $meta->{'name'} or die( "No name for distro?\n" . Dumper($meta) );
    $meta->{'name'} =~ s/\\?'/-/g;    # Acme::Can't
    $build_json->{'name'} eq $meta->{'name'} or die( "Bad detection of name?\n" . Dumper( $meta, $build_json ) );
    delete $meta->{'name'};

    # Validate we detected version correctly.
    $meta->{'version'} or die( "No version for distro?\n" . Dumper($meta) );
    $build_json->{'version'} eq $meta->{'version'} or die( "Bad detection of version?\n" . Dumper( $meta, $build_json ) );
    delete $meta->{'version'};

    if ( $build_json->{'builder'} eq 'play' && %$meta ) {
        $self->dump_self;
        die("Unparsed information still exists in dist_meta. Please review.");
    }

    File::Slurper::write_text( $self->BUILD_file, Cpanel::JSON::XS->new->pretty->canonical( [1] )->encode($build_json) );
    $self->git->add( $self->BUILD_file );

    return;
}

sub is_dual_life ( $self, $module ) {
    length $module or return;
    my $v = Module::CoreList->first_release($module);
    return length $v ? 1 : 0;
}

sub merge_dep_into_hash ( $from, $to ) {
    ref $from eq 'HASH' or die ref $from;
    ref $to eq 'HASH'   or die ref $to;

    foreach my $key ( keys %$from ) {
        next if $to->{$key} && $to->{$key} + 0 > $from->{$key} + 0;
        $to->{$key} = $from->{$key};
    }
}

sub prune_ref ($var) {
    my $type = ref $var;
    if ( $type eq 'HASH' ) {
        foreach my $key ( keys %$var ) {
            my $value      = $var->{$key};
            my $value_type = ref $value;
            if ($value_type) {
                prune_ref($value);
            }
            delete $var->{$key} if ( $value_type eq 'ARRAY' && !@{$value} );
            delete $var->{$key} if ( $value_type eq 'HASH'  && !%{$value} );
        }
    }
    return;
}

sub get_ppi_doc ( $self, $filename ) {
    return if $filename =~ m{\.(bak|yml|json|yaml|txt|out|htm|html|tt|tt2|pro|js|css|ps|xml|xhtml|po|mo|tt2|fdb|xls|xlsx|csv|tab|jpg|jpeg|png|gif|fla|swf|sql|eye|eyp|doc|docm|ppt|c|cpp|h|dat|zip|gz|tar|jar|java)$}i;
    return if $filename =~ m{share/|share-module/};                                                                                                                                                                       # Skip share files. They're not perl code.
    return if $self->is_extra_files_we_ship($filename);

    if ( -l $filename || -d _ || -z _ ) {
        warn("$filename isn't a normal file. Skipping PPI parse");
        return;
    }

    return $self->ppi_cache->{$filename} if exists $self->ppi_cache->{$filename};

    print "PPI $filename\n";

    #    my $content = File::Slurper::read_text($filename);
    #my $content = $self->try_to_read_file($filename);

    # Some perl modules have a BOM in the head of their file.
    print "Open $filename\n";
    File::BOM::open_bom( my $fh, $filename, ':utf8' );

    my $content  = '';
    my $encoding = 'utf8';
    while ( my $line = <$fh> ) {
        if ( $line =~ m/^=encoding\s+(\S+)/ ) {
            $encoding = $1;
            if ( $encoding =~ m/^utf\-?8\z/i ) {
                $encoding = 'utf8';
            }
            else {
                last;
            }
        }
        $content .= $line;
    }

    # If we detected a change in encoding,
    if ( $encoding ne 'utf8' ) {
        close $fh;

        if ( $encoding =~ m/iso8859/i ) {
            print "Re-open $filename latin1\n";
            open( $fh, '<', $filename );
        }
        else {
            print "Switching encoding to $encoding\n";
            File::BOM::open_bom( $fh, $filename, ":$encoding" );
        }
        $content = do { local $/; <$fh> };
    }

    close $fh;

    local $@;
    my $cache = $self->ppi_cache->{$filename} = PPI::Document->new( \$content );
    print( "ERR: " . Dumper $@) if $@;

    return $cache;
}

sub _file_to_package ( $filename ) {
    $filename or die;
    $filename =~ s{^lib/}{};
    $filename =~ s{\.(pm|pod)$}{};
    $filename =~ s{/}{::}g;
    return $filename;
}

sub _package_to_file ( $package ) {
    $package or die;
    $package =~ s{::}{/}g;
    $package = "lib/$package.pm";
    return $package;
}

sub is_xt_test ( $self, $filename ) {
    return 0 unless $filename =~ m{^t/.+\.t$};

    my $doc = $self->get_ppi_doc($filename) or return 0;

    return 1 if grep { $_ eq $filename } qw{t/release-distmeta.t t/release-has-version.t t/pod-coverage.t};

    # remove pods
    my $quotes = $doc->find( sub { $_[1]->class =~ m/^PPI::Token::Quote::/ } ) || [];

    # Look for comments about this being an author test.
    foreach my $quote (@$quotes) {
        my $content = $quote->content;
        return 1 if $content =~ m{SKIP these tests are for testing by the author};
        return 1 if $content =~ m{SKIP these tests are for release candidate testing};
    }

    return 0;
}

sub parse_builders_for_share ($self) {
    my $DOTDIRS  = 0;
    my $DOTFILES = 0;
    my @share_directives;

    my $dist   = 0;
    my $module = 0;
    if ( $self->builder_builder eq 'minilla' ) {    # We can just assume minilla is going to support the share dir.
        if ( -d 'share' ) {
            push @share_directives, ['install_share'];
            $dist = 1;
        }

    }
    elsif ( -f 'Build.PL' ) {
        my $doc = $self->get_ppi_doc('Build.PL');
        $doc or die;
        my (@value) = $self->_ppi_find_and_parse_value_for_key( $doc, 'share_dir' );
        if (@value) {
            @value == 1 or die Dumper \@value;
            push @share_directives, [ 'install_share', $value[0] ];
            $DOTDIRS = $DOTFILES = 1;    # M::B doesn't seem to support dropping dot file/dirs.
        }
    }
    elsif ( -e 'Makefile.PL' ) {
        my $doc = $self->get_ppi_doc('Makefile.PL');

        my $sharedir_vars = $doc->find( sub { $_[1]->class eq 'PPI::Token::Symbol' && $_[1]->content =~ m{^\$File::ShareDir::Install::} } ) || [];
        foreach my $sharedir_var (@$sharedir_vars) {
            my ($var) = $sharedir_var->content =~ m/::(INCLUDE_DOT[A-Z]+)$/ or die( $sharedir_var->content );

            my $node = $sharedir_var->snext_sibling;
            $node->class eq 'PPI::Token::Operator' and $node->content eq '=' or die( dump_tree( $sharedir_var->parent, "Unexpected sequence for \$File::ShareDir::Install::" ) );

            $node = $node->snext_sibling;
            $node->class eq 'PPI::Token::Number' or die( dump_tree( $sharedir_var->parent, "Unexpected value for \$File::ShareDir::Install::" ) );

            $DOTDIRS  = $node->content if $var eq 'INCLUDE_DOTDIRS';
            $DOTFILES = $node->content if $var eq 'INCLUDE_DOTFILES';
        }

        # find: install_share dist => "share";
        my $install_shares = $doc->find(
            sub ( $self, $node ) {
                $node->class eq 'PPI::Statement' or return 0;
                my $child = $node->schild(0);
                $child->class eq 'PPI::Token::Word' or return 0;
                $child->content eq 'install_share'  or return 0;
                return 1;
            }
        ) || [];

        foreach my $node (@$install_shares) {
            $node = $node->schild(0);
            my @share_directive = qw/install_share/;
            while ( $node = $node->snext_sibling ) {
                my $content = $node->content;
                my $class   = $node->class;

                next if $class eq 'PPI::Token::Operator';
                last if $class eq 'PPI::Token::Structure' and $content eq ';';

                push @share_directive, strip_quotes( $node->content );
            }
            push @share_directives, [@share_directive];

        }

        # Module::Install doesn't do DOTFILES or DOTDIRS exclusions
        if ( $doc->find( sub ( $self, $node ) { $node->class eq 'PPI::Statement::Include' && $node->content =~ m{inc::Module::Install} } ) ) {
            $DOTDIRS = $DOTFILES = 1;
        }
    }

    foreach my $share (@share_directives) {

        # install_share;
        # install_share dist => "share";
        if ( @$share == 1 or ( @$share == 3 && $share->[1] eq 'dist' && $share->[2] eq 'share' ) ) {
            $dist = 1;
        }

        # install_share "images";
        # install_share dist => 'config';
        elsif ( ( @$share == 3 && $share->[1] eq 'dist' ) or @$share == 2 ) {
            my $share_dist_path = $share->[-1];
            $self->merge_path( $share_dist_path, 'share' );

            $dist = 1;
        }
        elsif ( @$share == 5 && $share->[1] eq 'module' ) {
            my ( undef, undef, $module, $path ) = @$share;
            $module =~ s/::/-/g;
            $self->merge_paths( $path, "share-module/$module" );

            $module = 1;
        }
        else {
            die "Unknown share directive: ", join( " => ", @$share );
        }
    }

    # $DOTDIRS = $DOTFILES = 1;
    # share dir but no share directives. Let's remove share/
    if ( !@share_directives && -d 'share' ) {
        $self->git->rm( '-rf', 'share' );
    }
    elsif (@share_directives) {
        my @share_dirs;
        push @share_dirs, 'share'        if $dist;
        push @share_dirs, 'share-module' if $module;

        if ( !$DOTDIRS ) {
            print "DDD=$DOTDIRS DDF=$DOTFILES\n";
            ...;    # I need a repo that wants this.
            my @dot_dirs_found;
            File::Find::find( sub { next unless -d $_; next unless substr( $_, 0, 1 ) eq '.'; push @dot_dirs_found, $File::Find::name }, @share_dirs );
        }
        if ( !$DOTFILES ) {
            print "DDD=$DOTDIRS DDF=$DOTFILES\n";
            ...;
        }

        # Store the share files so we know to keep them later.
        push @{ $self->share_files }, $self->git->ls_files('share')        if $dist;
        push @{ $self->share_files }, $self->git->ls_files('share-module') if $module;
        $self->reset_repo_files;
    }

    return;
}

sub merge_path ( $self, $from_dir, $to_dir ) {
    return unless -d $from_dir;
    mkpath($to_dir);

    my $git = $self->git;

    my @files = map { substr( $_, length($from_dir) + 1 ) } sort { length($b) <=> length($a) } $git->ls_files($from_dir);
    foreach my $file (@files) {
        my $share_path = "$to_dir/$file";

        mkpath($share_path);
        rmdir $share_path;

        $git->mv( '-f', "$from_dir/$file", $share_path );

        my ( undef, $dir, undef ) = File::Spec->splitpath($file);
        rmdir "$from_dir/$dir";
    }
}

sub parse_maker_for_scripts ($self) {

    my $distro  = $self->distro;
    my $scripts = $self->scripts;

    # Catfiles that are too hard to parse.
    push @{$scripts}, 'bin/ook'       if $distro eq 'Acme-Ook';
    push @{$scripts}, 'bin/wt'        if $distro eq 'HTTP-WebTest';
    push @{$scripts}, 'bin/mt-upload' if $distro eq 'Net-MovableType';
    push @{$scripts}, 'bin/sys'       if $distro eq 'VCS-SaVeS';
    push @{$scripts}, 'bin/axk'       if $distro eq 'XML-Axk';
    return if @{$scripts};

    # parse x_provides_scripts to find the scripts this distro ships.
    my $meta = $self->dist_meta;
    if ( exists $meta->{'x_provides_scripts'} ) {
        if ( ref $meta->{'x_provides_scripts'} eq 'HASH' ) {
            foreach my $provides ( values %{ $meta->{'x_provides_scripts'} } ) {
                ref $provides eq 'HASH' or die( "Unexpected format to x_provides_scripts:\n" . Dumper $meta);
                push @$scripts, $provides->{'file'};
            }
            return;
        }
    }

    if ( $self->builder_builder eq 'minilla' ) {
        my $c = $self->try_to_read_file('minil.toml');
        if ( $c && $c =~ /script_files/msi ) {
            ...;    #Let's wait and see if we get one of these.
        }

        # This is the default.
        my @files = $self->git->ls_files( 'bin/*', 'script/*' );
        if (@files) {
            push @{$scripts}, @files;
        }
        return;
    }

    if ( -e 'Build.PL' ) {
        my $doc = $self->get_ppi_doc('Build.PL');

        push @$scripts, $self->_ppi_find_and_parse_value_for_key( $doc, 'script_files' );
        return;
    }

    if ( -e 'Makefile.PL' ) {
        my $doc = $self->get_ppi_doc('Makefile.PL');

        # my @scripts = grep {-f } glob("scripts/*.pl "); # Ripped from Text::PDF
        if ( $doc->find( sub ( $self, $node ) { $node->class eq 'PPI::Statement::Variable' && $node->content =~ m{glob\(\s*"scripts/\*\.pl\s*"\)} } ) ) {
            push @$scripts, glob('scripts/*.pl');
            return;
        }

        push @$scripts, $self->_ppi_find_and_parse_value_for_key( $doc, 'EXE_FILES' );
        return if @{$scripts};    # Must be EU::MM cause we got something!

        # Look for Module::Install stuff.
        my $statements = $doc->find( sub { $_[1]->class eq 'PPI::Statement' } ) || [];
        foreach my $statement_node (@$statements) {
            my $node = $statement_node->schild(0);
            $node->class eq 'PPI::Token::Word' && $node->content eq 'install_script' or next;
            $node = $node->snext_sibling;
            $node->class =~ m/^PPI::Token::Quote/ or die( "Unexpected token after install_script: " . Dumper($node) );

            push @$scripts, strip_quotes( $node->content );
        }
    }
}

# Parses the values from:
# 'my_key' => [qw/ abc 123 /], ...
# 'my_key' => ['abc', 123 ], ...

sub _ppi_find_and_parse_value_for_key ( $self, $doc, $key_name ) {

    my $key_nodes = $doc->find( sub { $_[1]->class =~ m/^PPI::Token::Quote::|^PPI::Token::Word$/ && $_[1]->content =~ m{^['"]?(\Q$key_name\E)['"]?$} } );

    $key_nodes or return;               # Couldn't find anything.
    ref $key_nodes eq 'ARRAY' or die;

    # Verify the next sibling is '=>'
    my $node = $key_nodes->[0]->snext_sibling();
    $node->content eq '=>' or die dump_tree( $key_nodes, "Unexpected sibling to $key_name" );

    # Next sibling is [] right?
    $node = $node->snext_sibling();
    if ( $node->class eq 'PPI::Structure::Constructor' ) {    # or die( "Unexpected sibling value $key_name: " . dump_tree($node) );
        my @list;
        my ($list_nodes) = $node->schildren;
        $list_nodes or return;                                # Nothing in the list.
        foreach my $list_node ( $list_nodes->children ) {
            next   if $list_node->class eq 'PPI::Token::Operator';
            next   if $list_node->class eq 'PPI::Token::Whitespace';
            return if $list_node->class eq 'PPI::Token::Word';         # Looks like code not a list. Forget it!

            next if $list_node->content =~ m/^\s*qw[\[(]\s*[\])]\s*\z/;    # qw()

            push @list, _ppi_get_list_from_quote_or_quote_like_words($list_node);
        }
        return @list;
    }

    return _ppi_get_list_from_quote_or_quote_like_words($node);
}

sub _ppi_get_list_from_quote_or_quote_like_words ($node) {
    my @list;

    if ( $node->class eq 'PPI::Token::QuoteLike::Words' ) {    # qw( abc def )
        my $content = $node->content;
        $content =~ s{^qw[\[(/](.*)[)/\]]$}{$1}msi;            # Strip out qw()
        push @list, split( " ", $content );                    # magical split on " "
    }
    elsif ( $node->class =~ m{^PPI::Token::Quote::} ) {
        push @list, strip_quotes( $node->content );
    }
    else {
        die dump_tree( $node, "Unexpected class for quote/list node" );
    }

    return @list;
}

sub parse_comments ( $self, $filename ) {

    my $doc = $self->get_ppi_doc($filename) or return;

    # remove pods
    my $comments = $doc->find('PPI::Token::Comment') || [];

    # Search for abstract if the file is the primary package
    my $primary_package = $self->BUILD_json->{'primary'};
    if ( $primary_package eq _file_to_package($filename) ) {
        foreach my $comment (@$comments) {
            my $content = $comment->content;
            if ( $content =~ m/^# ABSTRACT:\s+(\S.+$)/ && !$self->BUILD_json->{'abstract'} ) {
                $self->BUILD_json->{'abstract'} = "$1";
                chomp $self->BUILD_json->{'abstract'};
            }
            if ( $content =~ m/under the same terms as Perl itself/msi && !length $self->BUILD_json->{'license'} ) {
                $self->BUILD_json->{'license'} = 'perl';
            }

        }
    }
}

sub parse_pod ( $self, $filename ) {
    return unless $filename =~ m/\.(?:pl|pm|pod)$/i;    # only perl files for pod.

    my $doc = $self->get_ppi_doc($filename) or return;

    my $primary_package = $self->BUILD_json->{'primary'};

    # remove pods
    my $pods = $doc->find('PPI::Token::Pod') || [];

    my $abstract;
    my @author;

    foreach my $pod (@$pods) {
        my @pod_lines = split( "\n", $pod->content );
        while (@pod_lines) {
            my $license_data = '';
            my $line         = shift @pod_lines;
            if ( $line =~ m{^=head1 NAME} ) {
                while ( @pod_lines && $pod_lines[0] && $pod_lines[0] !~ m/^=/ ) {
                    my $line = shift @pod_lines;
                    next unless $line =~ m/^\s*\Q$primary_package\E(?:.pm)?\s+-\s+(.+)/;    # Skip empt
                    $abstract = $1;
                    $abstract =~ s/\s+$//;                                                  # Strip off trailing white space.

                    $self->BUILD_json->{'abstract'} = $abstract;
                    last;
                }
            }
            if ( $line =~ m{^=head1 AUTHOR} ) {
                while ( @pod_lines && $pod_lines[0] !~ m/^=/ ) {
                    my $line = shift @pod_lines;
                    next unless $line =~ m/\S/;
                    if ( $line =~ m/copyright|terms|disclaimers of warranty|free software|redistribute|itself/i ) {
                        $license_data .= $line;
                        next;
                    }
                    $line =~ s/^\s+//;
                    $line =~ s/\s+\z//;
                    if ( !$self->BUILD_json->{'maintainers'} ) {
                        $self->BUILD_json->{'maintainers'} = \@author;
                    }
                    push @author, $line;
                }
            }
            if ( $line =~ m{^=head1 CONTRIBUTORS} ) {
                while ( @pod_lines && $pod_lines[0] !~ m/^=/ ) {
                    my $line = shift @pod_lines;
                    next unless $line =~ s/Author:\s*(\S.+)/$1/;
                    if ( !$self->BUILD_json->{'maintainers'} ) {
                        $self->BUILD_json->{'maintainers'} = \@author;
                    }
                    push @author, $line;
                }
            }
            if ( $line =~ m{^=head1 (COPYRIGHT|LICENSE|LICENCE|LEGALESE)|^=head1 .+ E COPYRIGHT}i ) {

                $self->BUILD_json->{'license'} = 'MIT' if ( $line =~ m/the mit license/i );    # =head1 COPYRIGHT AND LICENSE (The MIT License)

                while ( @pod_lines && $pod_lines[0] !~ m/^=(cut|head)/ ) {
                    my $line = shift @pod_lines;
                    next unless $line =~ m/\S/;
                    $license_data .= " $line";
                }
            }

            $self->parse_text_for_license($license_data);
        }
    }

    return;
}

sub parse_text_for_license ( $self, $license_data ) {

    return unless $license_data;
    return if $self->BUILD_json->{'license'};

    $license_data =~ s/\s\s+/ /msg;    # Strip double spaces to make parsing the text easier.
    $license_data =~ s/\s/ /msg;       # Convert all white space to a single space.

    if ( $license_data =~ m/(or|under) the Artistic License|/msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }
    elsif ( $license_data =~ m/Terms (of|as) Perl itself/msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }                                  # This module is licensed under the same terms as perl itself
    elsif ( $license_data =~ m{same as Perl itself|you can redistribute it and/or modify it under the same terms as the perl 5 programming language system itself|under the same terms as perl\.|is licensed under the same terms as perl itself}msi ) {
        print "HERE\n";
        return $self->BUILD_json->{'license'} = 'perl';
    }
    elsif ( $license_data =~ m/L<perlartistic>/msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }
    elsif ( $license_data =~ m{This distribution is free software; you can redistribute it and/or modify it under the Artistic License 2.0|licensed under: The Artistic License 2.0|artistic_license_2_0}msi ) {
        return $self->BUILD_json->{'license'} = 'Artistic_2_0';
    }
    elsif ( $license_data =~ m/under the terms of the Perl Artistic License/msi ) {
        return $self->BUILD_json->{'license'} = 'perl';
    }
    elsif ( $license_data =~ m/under the terms of GNU General Public License \(GPL\)/msi ) {
        return $self->BUILD_json->{'license'} = 'GPL';
    }
    elsif ( $license_data =~ m/under the terms of GNU General Public License 3/msi ) {
        return $self->BUILD_json->{'license'} = 'GPLv3+';
    }
    elsif ( $license_data =~ m/MIT License/msi ) {
        return $self->BUILD_json->{'license'} = 'MIT';
    }
    elsif ( $license_data =~ m/the Mozilla Public License Version 1\.1/msi ) {
        return $self->BUILD_json->{'license'} = 'Mozilla_1_1';
    }
    elsif ( $license_data =~ m/under the terms of the Apache 2.0 license/msi ) {
        return $self->BUILD_json->{'license'} = 'Apache_2_0';
    }
    elsif ( $license_data =~ m/L<Software::License::(\S+)>/msi ) {
        return $self->BUILD_json->{'license'} = "$1";
    }
    elsif ( $license_data =~ m/into the public domain|This module is in the public domain/msi ) {
        return $self->BUILD_json->{'license'} = "PublicDomain";
    }

    #die "Unknown license: $license_data==\n";
    return;
}

sub parse_specail_files_for_license ($self) {
    return if $self->BUILD_json->{'license'};

    foreach my $file (qw/README LICENSE COPYING/) {
        next unless -f $file && !-z _;
        my $c = File::Slurper::read_binary($file) || '';
        return if $self->parse_text_for_license($c);
    }

    return;
}

sub parse_code ( $self, $filename ) {

    my $requires_runtime_hash;
    $requires_runtime_hash = $self->requires_build   if $filename =~ m{^t/.+\.(pl|pm|t)$}i;
    $requires_runtime_hash = $self->requires_runtime if $filename =~ m{\.pm$} && $filename !~ m{^t/};
    $requires_runtime_hash = $self->requires_develop if $filename =~ m{^xt/.+\.t$};
    return unless $requires_runtime_hash;    # Doesn't look like perl code we know about.

    my $doc = $self->get_ppi_doc($filename) or return;
    if ( $filename eq 'lib/ACME/QuoteDB/DB/DBI.pm' ) {
        die dump_tree( $doc, "QuoteDB" );
        exit;
    }

    # find use/require statements and parse them.
    my $use_find = $doc->find('PPI::Statement::Include') || [];
    foreach my $use_node (@$use_find) {
        my (@modules) = get_package_usage($use_node) or next;
        $requires_runtime_hash->{$_} = 0 foreach @modules;
    }

    my $primary_module = $self->BUILD_json->{'primary'};

    return unless $filename =~ m{\.(t|pm)$} && $filename =~ m{^(t|lib)/};
    my $provides_hash = ( $filename =~ m/^lib/ ) ? $self->provides : $self->test_provides;

    # Find any DBI->connects.
    my $dbi_nodes = $doc->find(
        sub ( $self, $node ) {
            $node->class eq 'PPI::Token::Word' or return 0;    # DBI
            $node->content eq 'DBI' or return 0;

            $node = $node->snext_sibling;
            $node->class eq 'PPI::Token::Operator' or return 0;    # DBI->
            $node->content eq '->' or return 0;

            $node = $node->snext_sibling;
            $node->class eq 'PPI::Token::Word' or return 0;        # DBI->connect
            $node->content eq 'connect' or return 0;

            return 1;

        }
    ) || [];
    foreach my $dbi_node (@$dbi_nodes) {
        my $c = $dbi_node->snext_sibling->snext_sibling->snext_sibling->content;
        my ($DBD) = $c =~ m/[\"'\(\{]DBI:(\S+):/;
        $requires_runtime_hash->{"DBD::$DBD"} = 0;
    }

    # Find packages that are provides.
    my $packages_find = $doc->find('PPI::Statement::Package') || [];

  PACKAGE: foreach my $pkg_token (@$packages_find) {
        my $module = get_package_provided($pkg_token) or next;

        $provides_hash->{$module}->{'file'}    = $filename;
        $provides_hash->{$module}->{'version'} = 0;

        # Try to determine the VERSION value in each package.
        while ( $pkg_token = $pkg_token->snext_sibling ) {

            #print dump_tree($pkg_token, "NEXT LINE\n");
            my $class = $pkg_token->class;
            last if $class eq 'PPI::Statement::Package';
            next unless $class =~ m/^(PPI::Statement|PPI::Statement::Variable|PPI::Statement::Compound|PPI::Statement::Scheduled)$/;

            my $nodes = $pkg_token->find( sub { ( $_[1]->content eq '$VERSION' | $_[1]->content eq "\$${module}::VERSION" ) && $_[1]->class eq 'PPI::Token::Symbol' } ) or next;
            foreach my $node (@$nodes) {
                my $node = $nodes->[0];
                $node = $node->snext_sibling;
                if ( !ref $node ) {

                    # Possibly ( $VERSION ) = ...
                    eval { $node = $nodes->[0]->parent->parent->snext_sibling };
                    ref $node or die;
                }
                $node->class eq 'PPI::Token::Operator' or next;
                $node->content eq '='                  or next;
                $node = $node->snext_sibling;

                my $version;

                # Try to handle all the stupid things people have done with version lines :(
                if ( $node->class =~ m/^PPI::Token::(Quote|Number)/ ) {
                    $version = $node->content;
                    $version = strip_quotes($version);
                    if ( $version =~ m/Revision: ([0-9.]+)/ ) {    # ( $VERSION ) = '$Revision: 1.9 $ ' =~ /\$Revision:\s+([^\s]+)/;
                        $version = $1;
                    }
                }
                elsif ( $node->class eq 'PPI::Token::Word' && $node->content eq 'qv' ) {    # our $version = qv{v0.0.2}
                    $node = $node->snext_sibling;
                    $node->class eq 'PPI::Structure::List' or die dump_tree( $node, "structure list wrong" );

                    $node = $node->schild(0);
                    $node->class eq 'PPI::Statement::Expression' or die dump_tree( $node, "ppi-sta-express" );

                    $node = $node->schild(0);
                    $node->class =~ m/^PPI::Token::Quote::/ or die dump_tree( $node, "PPI::Token::Quote::" );

                    $version = $node->content;
                    $version =~ s/^\s*['"](.+)['"]\s*$/v$1/;                                # Make it a v-string since that's what they were going for.
                    $version =~ s/^vv/v/;                                                   # Sometimes the v is already there. strip off the duplicate.
                }
                elsif ( $node->class eq 'PPI::Token::Word' && $node->content eq 'version' ) {    # our $VERSION = version->.....
                    $node = $node->snext_sibling;                                                # ->
                    $node->class eq 'PPI::Token::Operator' or die dump_tree( $node, "PPI::Token::Operator" );

                    $node = $node->snext_sibling;                                                # declare
                    if ( $node->class eq 'PPI::Token::Word' && $node->content eq 'declare' ) {   # our $VERSION = version->declare('v0.2.2');

                        $node = $node->snext_sibling;                                            # ( ... )
                        $node->class eq 'PPI::Structure::List' or die dump_tree( $node, 'PPI::Structure::List' );

                        $node = $node->schild(0);
                        $node->class eq 'PPI::Statement::Expression' or die dump_tree( $node, 'PPI::Statement::Expression' );

                        $node = $node->schild(0);
                        $node->class =~ m/^PPI::Token::Quote::/ or die dump_tree( $node, '^PPI::Token::Quote::' );

                        $version = $node->content;
                        $version =~ s/^\s*['"](.+)['"]\s*$/v$1/;                                 # Make it a v-string since that's what they were going for.
                    }
                    elsif ( $node->class eq 'PPI::Token::Word' && $node->content eq 'parse' ) {    # our $VERSION = version->parse('v0.2.2')->numify;

                        my $next = $node = $node->snext_sibling;                                   # ( ... )
                        $node->class eq 'PPI::Structure::List' or die dump_tree($node);

                        $node = $node->schild(0);
                        $node->class eq 'PPI::Statement::Expression' or die dump_tree($node);

                        $node = $node->schild(0);
                        $node->class eq 'PPI::Token::Number::Version' or die dump_tree( $nodes->[0]->parent );
                        $version = strip_quotes( $node->content );

                        $node = $next->snext_sibling;
                        $node->class eq 'PPI::Token::Operator' && $node->content eq '->' or die dump_tree( $nodes->[0]->parent );

                        $node = $node->snext_sibling;
                        $node->class eq 'PPI::Token::Word' && $node->content eq 'numify' or die dump_tree( $nodes->[0]->parent );
                        $version = version->parse($version)->numify;
                    }
                    else {
                        die dump_tree( $nodes->[0]->parent, "Failed to parse version-> declaration" );
                    }
                }
                elsif ( $node->class eq 'PPI::Token::Symbol' && $node->content =~ m/"?\$\Q$primary_module\E::VERSION"?$/ ) {    # our $VERSION = $accessors::fast::VERSION;
                    if ( !$provides_hash->{$primary_module} ) {

                        # Most of the time we process the primary module first
                        $self->parse_code( _package_to_file($primary_module) );
                        $provides_hash->{$primary_module} or die("Could not determine a VERSION for primary module $primary_module");
                    }
                    $version = $provides_hash->{$primary_module}->{'version'};
                }
                elsif ( $node->class eq 'PPI::Token::Word' && $node->content eq 'sprintf' ) {                                   # our $VERSION = sprintf "%d.%02d", q$Revision: 0.2 $ =~ /(\d+)/g;
                    my $pkg_token_content = $pkg_token->content;
                    if ( $pkg_token_content =~ m/Revision:\s*([0-9]+\.[0-9]+)\s*\$/ ) {
                        $version = $1;
                    }
                    elsif ( $pkg_token_content =~ m/([0-9.]+)/ ) {
                        $version = $1;
                    }
                    else {
                        die sprintf( "TOKEN (%s=%s): %s--\n", $node->class, $node->content, $pkg_token_content ) . dump_tree( $pkg_token, "Unexpected content in VERSION statement" );
                    }
                }
                elsif ( $pkg_token->content =~ m/Revision:\s*([0-9]+\.[0-9]+)\s*\$/ ) {
                    $version = $1;
                }
                else {
                    #                    my $str = $pkg_token->content;
                    #                    my ($version) = $str =~ m/sprintf.+Revision: ([0-9]+\.[0-9]+)/;

                    $self->dump_self;
                    $version or die sprintf( "TOKEN (%s=%s): %s--\n", $node->class, $node->content, $pkg_token->content ) . dump_tree( $pkg_token, "Unexpected content in VERSION statement" );
                }

                print "PROVIDES $module ($version)\n";
                $provides_hash->{$module}->{'version'} = $version;
                next PACKAGE;
            }
        }
    }

}

sub get_package_provided ($element) {
    my $token = $element->first_token;
    $token eq 'package' or die dump_tree( $element, "$token not a package?" );

    # Package statements where the package is on a different line than the package indicates that they are trying to hide it from the PAUSE parser.
    # We're going to do the same.
    $token = $token->next_sibling;
    if ( $token->class eq 'PPI::Token::Whitespace' && $token->content eq "\n" ) {
        print "Skipping detected package '$element' because of new line after package\n";
        return;
    }

    $token = $token->snext_sibling;
    $token and $token->class eq 'PPI::Token::Word' or die dump_tree( $element, "PPTOKWORD" );

    my $package = $token->content;
    $package =~ s/\\?'/::/g;         # Acme::Can't
    return if $package eq 'main';    # main is not a supported package on CPAN.

    return $package;
}

sub get_package_usage ($element) {
    my $top = $element;

    my $token       = $element->first_token;
    my $require_str = $token->content;
    return if ( $require_str eq 'no' );    # Not an include usually for 'no warnings...'
    $token =~ /^(use|require)$/ or die( dump_tree( $element, "$token not a sub?" ) );
    my $is_use = $1;

    $token = $token->snext_sibling;

    return if ( $token->content =~ m/^5\.\d+/ );    # skip use 5.xx
    if ( $token->content =~ m/^\s*\$/ ) {           # Dynamic require can't be parsed.
        printf( "Failed to parse require: %s\n", $token->content );
        return;
    }

    my $module = $token->content;
    return if $module eq 'main';                    # Main is not a legal CPAN package.
    $module =~ s/'/::/g;                            # Acme::Can't

    # use base 'accessors';
    if ( $is_use eq 'use' and $module =~ /^(base|parent)$/ ) {
        my @modules;
        $token = $token->snext_sibling;
        return if $token->class eq 'PPI::Token::Structure' and $token->content eq ';';    # use base;
        if ( $token->class eq 'PPI::Structure::List' ) {
            $token = $token->schild(0);
            $token->class eq 'PPI::Statement::Expression' or die;
            $token = $token->schild(0);

            push @modules, _ppi_get_list_from_quote_or_quote_like_words($token);

            while ( $token = $token->snext_sibling ) {
                next if $token->class eq 'PPI::Token::Operator';
                push @modules, _ppi_get_list_from_quote_or_quote_like_words($token);
            }

            return @modules;    # In this case, it's more than one module.
        }
        else {
            push @modules, _ppi_get_list_from_quote_or_quote_like_words($token);
        }

        return @modules;
    }

    # no imports for require.
    return $module if ( $is_use ne 'use' );

    # We need to know if imports are being blocked.
    $token = $token->snext_sibling or die( dump_tree( $top, "Should never happen?" ) );
    if ( $token->class eq 'PPI::Structure::List' && !$token->child(0) ) {
        return ($module);
    }

    # A module is loaded here but it allows imports (BOO!)
    return $module;
}

sub strip_quotes ($string) {
    $string =~ s/^qq?[\[(](.*)[)\]]\z/$1/ms and return $string;
    $string =~ s/^qw[\[(](.*)[\])]\z/$1/ms  and return $string;
    $string =~ s/^(['"])(.*)\1\z/$2/ms      and return $string;
    return $string;
}

sub dump_tree ( $element, $die_msg = '' ) {
    my $dump = PPI::Dumper->new($element);
    print "\n";
    $dump->print;
    return $die_msg ? $die_msg : "WHA WHA";
}

1;
